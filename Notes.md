# MySQL "Изучаем SQL". Автор книги: Алан Болье.

## Лайфхаки и тонкости.
Большинство реализаций SQL воспринимают /* ... */ как комментарий

Некоторые СУБД обязывают в запросе к себе указывать FROM и название таблицы.
Например СУБД Oracle. Для того, чтобы только вызвать встроенную функцию, Oracle
предоставляет таблицу dual с единственной строкой данных. Поэтому вызов функции
now() в Oracle Database выглядит следующим образом:

```
SELECT now() FROM dual;
```

При хранении строк возникают закономерные проблемы: строковые символы, иногда
даже одинакового значения, будут представлены в памяти во- первых по разному, а
во- вторых скорее всего с разным объемом занимаемой памяти. Виной всему в этом
несовершенном виде кодировки (сами по себе они то не виноваты, а скорее даже
полезны. Просто попали под горячую руку). Так вот, чтобы узнать, какие кодировки
доступны в MySQL необходимо ввести следующую инструкцию: 

```
SHOW CHARACTER SET;
mysql> SHOW CHARACTER SET;
+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
| ascii    | US ASCII                        | ascii_general_ci    |      1 |
```

При сортировке или группировке текстовых данных в MySQL используются только
первые 1024 байта. Это значение может быть увеличено.

## Типы данных.

### Символьные данные.

Символьные данные хрянятся в виде строк фиксированной или переменной длины.
Отличие строк с фиксированной длинной заключается в том, что они справа
дополняются пробелами, а также всегда занимают одно и то же число байт.

Задать ограничение на длину можно следующим образом:

```
char(20) /*Фиксированная длина */
varchar(20) /*Пременная длина*/
```

В MySQL существуют ограничения: char ограничен 255 байтами, а varchar 65535 байтами.

Чтобы указать кодировку, в которой хранится текст, при задании типа столбца необходимо её указать:

```
varchar(20) character set latin1
```

А также можно задать значение кодировки по- умолчанию для всей БД:

```
CREATE DATABASE DB1 CHARACTER SET latin1;
```

Текстовые данные. Данный тип данных позволяет обойти ограничение в 64 КБайт на размер текста. Подразделяется на:
- tinytext	255 Байт;
- text		65 535 Байт
- mediumtext	16 777 215 Байт;
- longtext	4 294 967 295 Байт.

После того, как varchar стал поддерживать до 64 КБайт текстовых данных, смысл в использовании tinytext и text отпал.

### Числовые типы данных.

#### Целые числа.

- tinyint (от -128 до 127), а беззнаковый вариант от 0 до 255
- smallint (от -32 768 до 32 767), а беззнаковый вариант от 0 до 65 535
- mediumint (от -8 388 608 до 8 388 607), а беззнаковый вариант от 0 до 16 777 215
- int (от -2 147 483 648 до 2 147 483 647), а беззнаковый вариант от 0 до 4 294 967 295
- bigint (от -2^63 до 2^63 - 1), а беззнаковый вариант от 0 до 2^64 - 1
Числа с плавающей точкой:
- float (p, s) тут какие- то уж адские диапазоны
- double (p, s)

При указании типа с плавающей точкой можно указать его точность (p - precision).
Это общее число цифр слева и справа от точки. Также можно указать масштаб (s -
scale). Это уже число цифр справа от точки.

#### Данные типа времядата (временнОй тип).
- date		YYYY-MM-DD от 1000-01-01 до 9999-12-31
- datetime	YYYY-MM-DD HH:MI:SS от 1000-01-01 00:00:00.000000 до 9999-12-31 23:59:59.999999
- timestamp 	YYYY-MM-DD HH:MI:SS от 1970-01-01 00:00:00.000000 до 2038-01-18 22:14:07.999999
- year		YYYY от 1901 до 2155
- time		HHH:MI:SSS от -838:59:59.000000 до 838:59:59.000000

СУБД берет на себя задачу по представлению входных данных в виде внутренней
реализации. Условием лишь является подача на вход строковых данных в требуемом
формате. Например для колонки с типом date подойдет такая строка: "2022-01-27"
Типы datetime и timestamp позволяют включать в себя миллионные доли секунды. Для
этого при задании таблицы необходимо указать в скобках трубуемую точность:
datetime (2).

## Создание базы данных.

База создается через конструкцию CREATE DATABASE;

Чтобы переключить контекст на необходимую базу и не вводить её название при
каждом обращении к таблицам внутри, используется конструкция USE 'название_
базы'

## Создание таблицы.

Таблица создается конструкцией CREATE TABLE ();

### Первичный ключ.
Первичный ключ используется для однозначной идетификации записи в таблице.
Первичный ключ должен быть уникальным, не может быть Nullable, а также  в одной
таблице может быть только один первичный ключ.

Первичный ключ можно задать при создании базы, описав его словно колонку:
PRIMARY KEY ('название_колонки' или 'описание_составного_ключа')

Также первичный ключ можно указать уже после создания таблицы через ALTER TABLE:
ALTER TABLE 'название_таблицы' ADD PRIMARY KEY ('название_колонки' или
'описание_составного_ключа')

MySQL позволяет в качестве первичного ключа использовать как и одну из
пользовательских колонок (что далеко не является оптимальным решением), так и
оставить эту задачу на разрешение движком СУБД. Во втором случае предлагается
припихнуть к числовому полю AUTO_INCREMENT

```
CREATE TABLE auto_increment_showing_table 
(
    person_id SMALLINT UNSIGNED AUTO_INCREMENT,
    name VARCHAR(30),
    PRIMARY KEY (person_id)
);
```

### Внешний ключ.
Внешний ключ используется для связи в базовом случае двух таблиц. Например,
существует таблица, хранящая в себе логи. В этой таблице представлены числовые
значения severity и facility. Чтобы иметь возможность транлировать их в
строковые представления создадим две дополнительные таблицы. В одной табличке
будут храниться сопоставления severity, а в другой facility.

```
mysql> create table table_foreig
(
  actor_id int unsigned,
  film varchar(30),
  constraint pk primary key (actor_id, film),
  constraint fk foreign key (actor_id) references table_prim(id));

Query OK, 0 rows affected (0.01 sec)
```

Чтобы задать внешний ключ необходимо создать колонку с такими же параметрами,
как и колонка, на которую этот ключ будет вести. Имеется ввиду тип данных,
ограничение на размер и так далее. После этого при создании новой таблицы
необходимо создать ограничение с помощью ключевого слова **CONSTRAINT**,
обозвать его как- нибудь, к примеру **fk**, что означает foreign key. А уже для
этого ограничения описать внешний ключ. Синтаксис достаточно прост: foreign key
(название_столбца_в_новой_таблице) references другая_таблица(колонка).

> Есть у меня подозрения, что функционал механизма ограничений не заканчивается
> лишь возможностью их создавать. Возможно, в качестве внешнего ключа можно
> применять именованые ограничения первичного ключа, но пока что этот момент не прояснен.

## Запрос SELECT.
При выполнении запроса сервер возвращает **результирующий набор**, а точнее, еще
одну таблицу.

Запрос SELECT состоит из следующих составных частей:
- select определяет, какие столбцы следует включить в результирующий набор;
- from определяет таблицы, из которых следует выбирать данные, а также те
  таблицы, которые должны быть соединены;
- where отсеивает ненужные данные;
- group by используется для группировки строк по общим значениям столбцов;
- having отсеивает ненужные данные;
- order by упорядочивает строки в результирующем наборе по одному или нескольким
  столбцам.

Предложение select, помимо выбора тех столбцов, которые необходимо запросить,
позволяет включать также:
- числовые или строковые литералы;
- выражения (к примеру математические);
- результаты работы вызова встроенных функций;
- результаты работы вызова пользовательских функций.

```
mysql> select language_id,
    'COMMON' language_usage,
    language_id * 3.1415 lang_pi_value,
    upper(name) UpperName
from language;
+-------------+----------------+---------------+-----------+
| language_id | lancuage_usage | lang_pi_value | UpperName |
+-------------+----------------+---------------+-----------+
|           1 | COMMON         |        3.1415 | ENGLISH   |
|           2 | COMMON         |        6.2830 | ITALIAN   |
|           3 | COMMON         |        9.4245 | JAPANESE  |
|           4 | COMMON         |       12.5660 | MANDARIN  |
|           5 | COMMON         |       15.7075 | FRENCH    |
|           6 | COMMON         |       18.8490 | GERMAN    |
+-------------+----------------+---------------+-----------+
```

Таким образом применение select расширяется, позволяя на лету изменять имена
колонок:

```
mysql> select 'bla-bla' bla_bla_column from user_table_1;
+----------------+
| bla_bla_column |
+----------------+
| bla-bla        |
+----------------+
```

А общий синтаксис выглядит как "select (значение из колонки/ результат
выражения/ литерал) (название колонки, куда это будет запихнуто) из таблицы
(название таблицы)"

> Чтобы подчеркнуть изменение имени колонки можно использовать ключевое слово **as**
> между запрашиваемым значением колонки и псевдонимом:

>```
>mysql> select now() as 'Время сейчас';
>+---------------------+
>| Время сейчас        |
>+---------------------+
>| 2023-02-25 02:09:41 |
>+---------------------+
>```


Помимо этого интересно и то, что from является хоть и немаловажной, но вовсе не
обязательной частью запроса SELECT. К примеру, можно запросить вызов встроенных
функций, а в этом случае отпадает необходимость в выборке столбцов из какой-
либо таблицы:

```
mysql> select now(), version(), database();
+---------------------+-----------+------------+
| now()               | version() | database() |
+---------------------+-----------+------------+
| 2023-02-19 00:15:59 | 8.0.32    | sakila     |
+---------------------+-----------+------------+
```

### Удаление дубликатов.

Чтобы избавиться от дубликатов достаточно добавить ключевое слово **distinct**
после предложения **select**:

```
mysql> select * from t1;
+------+
| col1 |
+------+
|    1 |
|    2 |
|    3 |
|    1 |
|    1 |
|    1 |
+------+

mysql> select distinct * from t1;
+------+
| col1 |
+------+
|    1 |
|    2 |
|    3 |
+------+
```

**На самом деле неявно к запросам select пристыковывается ключевое слово all, если**
**не указано другого, например distinct.**

Употребление distinct может заметно негативно повлиять на скорость выполнения
запроса к большому количеству данных по причине того, что оптимизатор выполнит
сортировку, а то и несколько.

### Предложение from.

*Предложение from определяет таблицы, используемые запросом, наряду со
средствами связывания таблиц вместе.*

### Таблицы.

В общем- то неверно думать о таблицах только как о строках, связанных воедино и
хранящихся в базе данных. Это неверно по причине того, что таблиц существует
несколько видов:

- Постоянные таблицы. Они создаются при помощи инструкции CREATE TABLE;
- Произвольные таблицы. Совокупность строк, возвращаемых подзапросами (WHERE,
  HAVING, FROM и так далее). Хранятся исключительно во временной памяти
  вычислительной машины;
- Временные таблицы. Изменяемые данные, хранящиеся в памяти. По сути,
  представляют собой такие же таблицы, но существуют лишь на протяжении времени
  сессии подключения к СУБД;
- Виртуальные таблицы. Создаются с помощью инструкции CREATE VIEW.

И объединяет это все многообразие то, что их можно запихнуть в предложение from.

### Производные таблицы. Таблицы, генерируемые подзапросами.

Подзапрос- запрос, содержащийся в другом запросе. Подзапросы могут быть окружены
скобками. В запросе select подзапросы могут быть встроены во многие места, но в
контексте использования from подзапрос определяет произвольную таблицу, которая
видна из всех других мест запроса.

Иными словами from создает временную таблицу, откуда затем выбираются строки для
обработки.

Пример:

```
mysql> select concat(cust.last_name, ' ', cust.first_name) Concatination
from 
(
  select first_name, last_name
  from customer
  where first_name = 'JESSIE'
) cust;

+---------------+
| Concatination |
+---------------+
| BANKS JESSIE  |
| MILAM JESSIE  |
+---------------+
```

Разберемся с запросом по порядку:
1) Сперва выполняется подзапрос from: он формирует таблицу, состоящую из колонок
   first_name и last_name и фильтрует её с применением подзапроса where;
2) Получившейся таблице присваивается псевдоним cust и именно это имя таблицы
   указывается в функции concat;
3) Родительский запрос select выбирает функцию конкатенации для каждой из строк
   таблицы cust и возвращает результат.

### Временные таблицы.

Обычно, любая реляционная СУБД позволяет создать временную таблицу, такую, чьи
данные хранятся до окончания транзакции, либо до окончания сеанса работы (в СУБД
от Oracle временные таблицы не удаляются при завершении сеанса работы). В MySQL
такие таблицы создаются с применением ключевого слова **TEMPORARY** после
предложения select.

```
create temporary table dummy table
(
  int_value int
);
```

Причем запрос show talbes не будет возвращать временную таблицу.

### Представление.

Представление - это запрос, который хранится в словаре данных (Шо такое словарь
данных никто не объясняет, но зато книжки пишут). Создается следующей
конструкцией:
```
create view 'название_представления' as ... 
```
Определение представления не принуждает СУБД к созданию новых данных. По своей
сути представление хранит лишь "фильтр". К которому в будущем можно будет
обратиться. Чтобы лучше освоиться с применением представлений, создадим таблицу,
в которую сложим 1 и 2, создадим представление, которое будет дергать из этой
таблицы те строки, в которых будет значение 2, а затем запросим все строки из представления:
```
create table t (value int);

insert t values (1), (2);

create view as my_view as (select * from t where value = 2);

select * from my_view;

+-------+
| value |
+-------+
|     2 |
+-------+
```

Механизм работы похож на временные таблицы, но применение представлений не
побуждает к использовнию дополнительной памяти (сделаем поблажку и не будем
считать те пару килобайт, необходимых для запоминания СУБД представления, как
расходование памяти).

### Связи таблиц.

В определении from я упомянул, что from определяет средство связывания таблиц.
Дело в том, что стандарт ANSI требует указания условий связывания таблиц, если в
запросе используется несколько таблиц (всяческие join'ы).

Можно перечислить таблицы через запятую в подзапросе from, MySQL неявно проведет
их объединение по принципам, с которыми я еще не знаком.

### Псевдонимы таблиц.

Когда происходит объединение таблиц в предложении from, необходим способ
различить, к какому столбцу происходит обращение. Сделать это можно двумя
путями:
- использовать полное имя 'имя_таблицы.имя_столбца';
- повесить таблице псевдоним, чтобы точно также использовать полное имя.

##### Как назначить таблице или столбцам псевдонимы?

Чтобы в запросе select переименовать таблицу достаточно следующей конструкции:

```
select * from table1 renamed_table;
```

Таким образом таблица была переименована в renamed_table.

А чтобы переименовать столбцы следует использовать следующую конструкцию:

```
select renamed_table.column1, renamed_table.column2 from table1 renamed_table;
```

Задача: Как навесить псевдоним двум стобцам из одной таблицы и двум столбцам из другой таблицы в запросе к двум таблицам сразу?

```
mysql> select table1.value 'value from table1' from test_table table1, test_table_2 table2;
+-------------------+
| value from table1 |
+-------------------+
|                 1 |
|                 2 |
+-------------------+

mysql> select table1.value 'value from table1', table2.value 'value from table2', table1.description, table2.description from test_table table1, test_table_2 table2;
+-------------------+-------------------+--------------+------------------+
| value from table1 | value from table2 | description  | description      |
+-------------------+-------------------+--------------+------------------+
|                 1 |                 4 | text         | это из таблицы 2 |
|                 2 |                 4 | another_text | это из таблицы 2 |
+-------------------+-------------------+--------------+------------------+
```

Вот таким образом. Достаточно лишь навесить псевдонимы таблицам, а затем
обратиться к столбцам по новым псевдонимам, после чего необходимо навесить
псевдонимы уже столбцам.

Задача: можно ли использовать ключевое слово AS при применении псевдонимов к таблицам?

Да, вполне. Достаточно после имени таблицы использовать ключевое слово и затем
указать псевдоним.

```
select * from table1 as t;
```

### Предложение where.
Задача: зачем нужно предложение where?

Применение where позволяет выделить необходимые данные из исходных при помощи
логических выражений. Таким образом предложение where выступает в роли фильтра.

##### Как применить where?
Задача: Пусть, имеется таблица. В таблице одна колонка value с типом int. В таблице две
записи, в одной в столбце value число меньшее 5, а в другой число равное 5. Как
запросить отдельно то и другое?

```
mysql> select * from table1 where value < 5;
+-------+
| value |
+-------+
|     1 |
+-------+

mysql> select * from table1 where value = 5;
+-------+
| value |
+-------+
|     5 |
+-------+
```

Задача: Как написать в этом же случае запрос с where, состоящий из логического
выражения, но такой, который вернет обе строки?

```
select * from table1 where value < 3 or value > 3;
+-------+
| value |
+-------+
|     1 |
|     5 |
+-------+
```

### Предложения group by и having.

Group by призван групировать. Группирует он интересным образом: допустим, в
таблица примерно такого вида:

```
+------+--------+------+--------+
| id   | name   | age  | salary |
+------+--------+------+--------+
|    1 | Дима   |   23 |    100 |
|    2 | Петя   |   23 |    200 |
|    3 | Вася   |   23 |    300 |
|    4 | Коля   |   24 |   1000 |
|    5 | Иван   |   24 |   2000 |
|    6 | Кирилл |   25 |   1000 |
+------+--------+------+--------+
```

Первым делом необходимо определиться с тем, а по какому критерию мы хотим
группировать. По этому критерию каждая группа будет считаться уникальной.
Например, можно группировать по имени, в таком случае у нас появится 6 групп,
ведь имена уникальны в таблице:

```
mysql> select name from workers group by name;
+--------+
| name   |
+--------+
| Дима   |
| Петя   |
| Вася   |
| Коля   |
| Иван   |
| Кирилл |
+--------+
```

А можно группировать по возрасту и в этом случае у нас уже начинает появляться
что- то интересное, ведь уникальных значений возраста меньше, нежели строк в
таблице, а именно, всего 3 (23, 24, 25):

```
mysql> select age from workers group by age;
+------+
| age  |
+------+
|   23 |
|   24 |
|   25 |
+------+
```

Отлично, получилось. Далее возникает интерес воспользоваться новоизученным
инструментом. На данный момент мне необходимо знать о том, что только одна
колонка может фигурировать в предложении group by, все остальные колонки должны
быть аггрегированы (аггрегация означает объединение. Поэтому агрегатные функции
носят такое название, посколько объединяют множественные значения в одно)

Путем достижения этой цели должно стать использование агрегатной функции, к
примеру, суммирование зарплат. Возможно узнать, какова средняя зарплата по
возрасту:

```
mysql> select age, sum(salary) from workers group by age;
+------+-------------+
| age  | sum(salary) |
+------+-------------+
|   23 |         600 |
|   24 |        3000 |
|   25 |        1000 |
+------+-------------+
```

Аналогично можно посчитать среднюю зарплату по возрасту:

```
mysql> select age, round(avg(salary),0) from workers group by age;
+------+----------------------+
| age  | round(avg(salary),0) |
+------+----------------------+
|   23 |                  200 |
|   24 |                 1500 |
|   25 |                 1000 |
+------+----------------------+
```

Задача: как вызвать функцию подсчета суммы элементов, функцию вычисления
среднего значения, функцию округления до 0 знаков после запятой и до 2 знаков
после запятой?

Получается, что применение group by формирует из первоначальных данных (одной
или нескольких объединенных таблиц) "подтаблички по- меньше", после этого СУБД
ожидает встретить функцию агрегации, чтобы упаковать множественные значения из
"подтабличек" в одно значение для каждой одной группы.

### Подробнее про having.

having используется для фильтрации результатов группировки. Пусть, есть желание
запросить только те возраста, средняя зарплата которых меньше 1000 у.е. Сделать
это можно следующим образом:

```
mysql> select age, round(avg(salary)) from workers group by age having round(avg(salary)) < 1000;
+------+--------------------+
| age  | round(avg(salary)) |
+------+--------------------+
|   23 |                200 |
+------+--------------------+
```

Having распознает и более сложные логические выражения с применением
конъюнкции, дизъюнкции и других.

### Предложение order by.

Полагаться на порядок следования строк в выводе СУБД не стоит. Его следует
считать случайным, хоть и в некоторых СУБД указывается ключ сортировки, по
которому можно предположить тот порядок, в котором СУБД выплюнет элементы.

Для сортировки тех данных, которые уже вот- вот готовы показаться пользователю
используется order by.

Синтаксис прост: необходимо написать order by в конце SQL- запроса, а после него
указать столбец, по которому будет происходить сортировка. В дополнение к этому
можно указать ключевое слово **desc**, что значит descending, то есть по-
убыванию, для сортировки по возрастанию возможно применить ключевое слово
**asc**, то есть ascending.

Если указать несколько столбцов в запросе, СУБД будет сортировать по первому
указанному, при обнаружении одинаковых значений в этом столбце, СУБД произведет
сортировку этих значений основываясь уже на значениях из второго столбца.

Задача: Как сортировать по указанному порядковому номеру столбца, а не по его
названию?

Для этого достаточно всего лишь указать число после оператора order by. Столбцы
нумеруются начиная с 1. В представленом далее запросе происходит сортировка по
второму столбцу:

```
mysql> select * from table1 order by 2;
```

Также можно через запятую указать несколько столбцов по их порядковым номерам:

```
mysql> select * from table1 order by 1, 2;
```

## Фильтрация.

Все инструкции SQL за исключением insert позволяют использование предложения
where.

Задача: как выглядит оператор "не равно" в MySQL?
Либо <>, либо !=.

Условие, применяемое с where состоит из операторов и операндов. Операнды могут
быть такими:
- числа;
- столбца таблицы или представления;
- строкового литерала;
- встроенной фунции, к примеру sum, concat или другой;
- подзапроса;
- списка выражений, к примеру ('value1', 'value2').

Операторы представлены следующими штуками- дрюками:
- Операторы сравнения: =, !=, <, >, <>, like, in и between;
- Арифметические операторы: +, -, *, /.

Задача: зачем нужен оператор between?

Оператор between является синтаксическим сахаром и позволяет упаковывать двойное
неравенство в более читаемый человеком вид. Следующие запросы идентичны:

```
mysql> select * from table1 where value1 <= 3 and value1 >= 1;

mysql> select * from table1 where value1 between 1 and 3;
```

### Условие членства.
Условие членства достигается путем использования оператора in. Как, к примеру, в
примере далее:

```
mysql> select * from table1 where value2 in (2, 3);
```

### Подзапросы.
При использовании диапазона не обязательно вручную перечислять чреез запятую все
возможные значения, вместо этого можно написать запрос, возвращающий одну
колонку, значения которой будут выступать диапазоном для in.

```
mysql> select value from table1 where value in (select value from table2);
```

### Условия соответствия.
Условия соответствия отличаются от рассмотренных ранее условий тем, что не
действуют в таком строгом виде. Эта концепция мне понятна, так что можно
обойтись рассмотрением полезных встроенных функций:

#### Функция left(колонка, число символов).
Функция left отрезает от значения из строки в колонке число указанных символов и
возвращает в качестве результата

#### Оператор LIKE.
Использование оператора like похоже на использование регулярных выражений.
Оператор like используется совместно с шаблоном, в котором понатыканы символы
подстановки. Синтаксис таков:

```
mysql> select some_text from table1 where some_text like '_A_T%S';
```

В примере выше шаблон '_A_T%S' может быть рассмотрен как "Первый символ строки
может быть любым, на втором месте символ A, на третьем месте опять любой символ,
после чего должен следовать символ T на четвертом месте, затем любые символы в
любом количестве вполь до момента, когда будет встречен символ S, на котором
строка и должна закончиться."

Задача: какие три типа символов подстановки бывают?
* _ - любой одиночный символ;
* % - любое число любых символов;
* A - конкретный символ.

#### Регулярные выражения.
Регулярные выражения применяются таким образом:

```
select value from table1 where value regexp '^[QY]';
```

Собственно говоря, обычные регулярки. Изучив их синтаксис однажды- использовать
возможно везде.

### NUll.
Null в SQL несет такой же смысл, как и во всех остальных известных мне местах.
Но существует исключение: **С Null нельзя сравнивать**. То есть выражение value
!= NULL некорректно. Вместо этого с null необходимо использовать операторы
**is** и **not**.

## Запросы к нескольким таблицам.

Таблицы через join можно объединять различными способами. Одии из них является
Декартово произведение.

### Декартово произведение. Перекрестное соедниение.

```
mysql> select c.first_name, a.address from customer c join address a;
```

Этот запрос выведет порядка 360000 записей, при этом в таблицах customer и
address всего около 600 записей. А откуда же взялись 360000? Прсто СУБД
предложила все возможные сочетания людей и адресов, перемножив 600 на 600 и
получив 360000 возможных вариантов.

### Внутренее соединение.

Возможно поменять предыдщуий запрос так, чтобы для каждого человека выводился
лишь его адрес. Для этого в таблице с людями присутствует колонка address_id,
она является внешним ключом для таблицы address. В таблице adress также есть
колонка address_id, являющаяся первичным ключом этой таблицы.

Чтобы решить поставленную задачу следует придерживаться такой логики:
"Многоуважаемая СУБД, пожалуйста, обрати внимание на поле address_id в таблице
customer, пройди по связи и посмотри в таблице поле address, соответствующее
этому address_id".

Реализация этой логики такова:

```
mysql> select c.first_name, a.address from customer c join address a on c.address_id = a.address_id;
```

Если в одной из таблиц присутствует значение address_id, а в другой нет- то
такая строка исключается из результирующего набора. (Чтобы не исключать строки с
отсутствующими значениями применяется внешнее соединение.)

**В продемонстрированном выше запросе применялось именно внутреннее соединение,
просто неявно.**

А вот так выглядит его явная форма:

```
mysql> select c.first_name, a.address from customer c inner join address a on c.address_id = a.address_id;
```

Задача: как можно исключить использование ключевого слова on при внутреннем
объединении?

Если столбцы, по которым производится объединение, имеют одинаковое название,
можно сделать финт ушами: использовать ключевое слово using:

```
mysql> select c.first_name, a.address from customer c inner join address a using (address_id);
```

Правда в таком случае стоит использовать скобки -_-

### Синтаксис соединения ANSI.

Синтаксис ANSI является более старым по сравнению с используемым SQL92. Все
популярные СУБД поддерживают оба синтаксиса, в принципе, синтаксис ANSI может
быть удобен в некоторых случаях. На этом синтаксисе внутреннее объединение
таблиц будет выглядеть следующим образом:

```
mysql> select c.first_name, a.address from customer c, address a where c.address_id = a.address_id;
```

Алан Болье отмечает, что новый синтаксис SQL92 имеет преимущество в
переносимости между серверами, в то время как старый ANSI могут не поддерживать
СУБД, разработанные после 1992 года. Также синтаксис SQL92 выигрывает в условиях
сложных запросах:

SQL92
```
mysql> select c.first_name, c.last_name, a.address from customer c inner join address a using (address_id) where a.postal_code = 52137;
```

ANSI
```
mysql> select c.first_name, c.last_name, a.address from customer c, address a where c.address_id = a.address_id and a.postal_code = 52137;
```

Этот пример приводит автор книги и утверждает, что синтаксис SQL92 выглядит
проще, потому что проще увидеть условия объединения, а также наглядно показано,
какой вид объединения используется. На мой взгляд, это не показательный пример.

### Соединение трех и более таблиц.

Для соединения трех и более таблиц необходимо "пристыковать одну к другой и одну
к другой и так далее.

таблица1 inner join таблица2 using() inner join таблица3 using()

```
mysql> select c.first_name, ct.city from customer c inner join address using (address_id) inner join city ct using (city_id);
```

Задача: влияет ли порядок перечисления таблиц в from на результат?

Не влияет. SQL является декларативным языком, так что нет никакой разницы, в
каком порядке были перечислены таблицы. СУБД самостоятельно позаботится об
объединении. Но существует механимзм, позволяющий строго указать порядок, в
котором следует присовывать одну таблицу к другой. Для этого следует
использовать ключевое слово straight_join в MySQL, force order в SQL Server или
другой подобный механизм в других СУБД.

### Использоание подзапросов в качестве таблиц.

А вот, собственно говоря, что тут имеется ввиду:
В предыдущем параграфе мы использовали связь между таблицами customer и address
через address_id, а также связь между address и city через city_id.

Можно сделать по другому. Через подзапрос можно сформировать таблицу, которая
содержит address_id и city. А вот уже и появляется возможность связать customer
и city через address_id.

Вот пример реализации:

```
mysql> select c.first_name, ct.city from customer c inner join (select address.address_id, city.city from address inner join city using (city_id)) ct using (address_id);
```
### Использование одной таблицы дважды.

Иногда возникает потребность соединиться с одной и той же таблицей несколько
раз. Чтобы это сделать необходимо использовать псевдонимы и просто лишь
соединиться два раза.

Если для соединения с таблицей необходимо прибегнуть к соединению с
промежуточной таблицей- значит, необходимо несколько раз соединиться и с
промежуточной.

### Самосоединение.

Внутри таблицы может присутствовать столбец, являющийся внешним ключом, который
ведет на столбец с первичным ключом в этой же таблице. К примеру, в таблице с
информацией о фильмах может содержаться столбец, показывающий на приквел к
фильму. Применяя самосоединение можно составить таблицу, в которой будет все
фильмы, а также будут указаны все приквелы.

Синтаксис, используемый для такого соединения не отличается от примененного
ранее.

## Работа с множествами.

union - логическое ИЛИ
intersect - логическое И
except - Вычесть кусок

При воыполнении операций со множествами над таблицами должны выполняться
некоторые уловия:

- Число столбцов в таблицах должно быть одинаковым;
- Типы данных в соответствующих столбцах должны быть одинаковыми, или должна
  быть возможность преобразования одного типа данных в другой;

### Оператор union.

Помимо оператора union существует и оператор union all. Разница между ними
заключается в том, что union удаляет дубликаты из результирующего набора в
отличие от union all.

```
mysql> select 1 num, 'a' str union select 1 num, 'a' str;     
+-----+-----+
| num | str |
+-----+-----+
|   1 | a   |
+-----+-----+
mysql> select 1 num, 'a' str union all select 1 num, 'a' str;
+-----+-----+
| num | str |
+-----+-----+
|   1 | a   |
|   1 | a   |
+-----+-----+
```

### Оператор intersect.

Пересечение. Также удаляет дубликаты, оператор intersect all дубликаты не
удаляет, а вообще этот оператор поддерживается далеко не всеми версиями MySQL.

### Оператор except.

Оператор except возвращает первый указанный набор за вычетом свопадающих
результатов из второго набора.

Также есть его разновидность- except all. Except all не отбрасывает дубликаты в
результирующем наборе.

## Генерация, обработка и преобразование данных.

### Управление точностью чисел.

- ceil() округляет к ближайшему большему целому числу;
- floor() округляет к ближайшему меньшему целому числу;
- round() округляет к ближайшему целому (если дробная часть больше либо равна
  0.5, то округление произойдет в большую сторону), вторым параметром можно
  указать число знаков после запятой в итоговом результате;
- truncate() всегда принимает два аргумента и отбрасывает столько знаков после
  запятой, чтобы их осталось ровно столько, сколько передано во втором
  параметре.

## Группировка и агрегация.

### Группировка.
Пусть есть таблица с данными о том, какой фильм, каким клиентом был взят на
прокат. В этой таблице хранится id клиента идентификатор фильма. Вполне вероятна
ситуация, при которой число строк в этой таблице больше чем число клиентов.
Просто клиенты брали больше одного фильма в аренду. Как в таком случае
посмотреть, какой клиент сколько фильмов брал?

Ответом становится группировка и агрегация. Необходимо запросить из таблицы
группированные данные по клиентам и агрегировать количество взятых ими фильмов.
Вот так может выглядеть такой запрос:

```
mysql> select customer_id, count(*) from rental group by customer_id;
```

Предложение group by будто бы разбивает таблицу rental на множество таблиц для
каждого значения customer_id. Затем применяется функция агрегации, вычисляющая
одно единственное значение для каждой из маленьких таблиц.

Стоит напомнить себе порядок выполнения предложений в SQL:
1) FROM;
2) WHERE;
3) GROUP BY;
4) HAVING;
5) SELECT.

### Агрегация.

Агрегатные функции призваны уместить множество значений в одно. Будь то
максимальное или минимальное значение в наборе, среднее значение или их
количество.

- max();
- min();
- avg();
- sum();
- count();

### Неявная и явная группировки.

При выполнении такого запроса появляется одна неявная группа- единственная
строка, содержащая результат выполнения функции агрегирования.

Во всех остальных случаях необходимо явно указывать способ группировки.

### Многостолбцовая группировка.

При группировки по нескольким столбцам, они перечисляются через запятую после
предложения GROUP BY без скобок.

### Генерация итоговых данных. WITH ROLLUP

Предложение WITH ROLLUP позволяет получить результирующий набор, в котором
возникнут дополнительные строки. В этих дополнительных строках будет записан
результат вычисления агрегатной функции но над группой.

К примеру добавление WITH ROLLUP к запроу, выводящему список актеров, список
рейтингов фильмов, в которых актер снимался, а также число фильмов для каждого
рейтинга, приведет к тому, что появятся дополнительные строки, содержащие общее
число фильмов, в которых снялся актер.

Пример без WITH ROLLUP

```
mysql> select fa.actor_id, f.rating, count(*) from film_actor fa inner join film f using (film_id) group by fa.actor_id, f.rating order by 1,2 limit 10;    
+----------+--------+----------+
| actor_id | rating | count(*) |
+----------+--------+----------+
|        1 | G      |        4 |
|        1 | PG     |        6 |
|        1 | PG-13  |        1 |
|        1 | R      |        3 |
|        1 | NC-17  |        5 |
|        2 | G      |        7 |
|        2 | PG     |        6 |
|        2 | PG-13  |        2 |
|        2 | R      |        2 |
|        2 | NC-17  |        8 |
+----------+--------+----------+
```

С WITH ROLLUP:

```
mysql> select fa.actor_id, f.rating, count(*) from film_actor fa inner join film f using (film_id) group by fa.actor_id, f.rating with rollup order by 1,2 limit 10; 
+----------+--------+----------+
| actor_id | rating | count(*) |
+----------+--------+----------+
|     NULL | NULL   |     5462 |
|        1 | NULL   |       19 |
|        1 | G      |        4 |
|        1 | NC-17  |        5 |
|        1 | PG     |        6 |
|        1 | PG-13  |        1 |
|        1 | R      |        3 |
|        2 | NULL   |       25 |
|        2 | G      |        7 |
|        2 | NC-17  |        8 |
+----------+--------+----------+
```

## Подзапросы

Подзапрос - запрос, содержащийся в другой инстркуции данных. Как и любой запрос
подзапрос возвращает результирующий набор, который может быть одного из трех
видов:
- одна строка, один столбец (скалярный подзапрос);
- несколько строк, один столбец (могут быть использованы в сочетании с in, not
  in, all, any. Использование all и any подразумевает также и использование
  операторов сравнения);
- несколько строк, несколько столбцов.

Результаты, возвращаемые подзапросами, являются временными таблицами.
Соответственно, когда вызывающая инструкция завершает выполнение, все результаты
подзапроса с памяти убираются.

Вот, как выглядит поздапрос:

```
mysql> select customer_id, first_name, last_name from customer where customer_id = (select max(customer_id) from customer);        
+-------------+------------+-----------+
| customer_id | first_name | last_name |
+-------------+------------+-----------+
|         599 | AUSTIN     | CINTRON   |
+-------------+------------+-----------+
```

Приведенный выше подзапрос участвует в предложении where. Он возвращает таблицу
с одной единственной строкой и одним столбцом. Это дает возможность использовать
результат подзапроса с оператором вычисления равенства. Если бы подзапрос вернул
несколько строк, его можно было бы использовать с операторами больше и меньше.
Но не с оператором равенства. В итоге запрос возвращает имя, фамилию и id
клиента с максимальным значением id.

Может показаться, что использовать подзапрос в этом случае вовсе необязательно и
можно обойтись подобным запросом:

```
mysql> select customer_id, first_name, last_name from customer where customer_id = max(customer_id);
```

Но нет, так сделать нельзя. СУБД ругается на неправильное применение функции к
группе. Думаю, суть в том, что max(customer_id имеет смысл только при применении
в теле запроса, то есть select max()).

Задача: что такое скалярный запрос?

Подзапросы можно разделить на два вида:
- некоррелированные;
- коррелированные.

Некоррелированные запросы независимы и могут выполняться автономно,
коррелированные же напротив, требуют наличия родительского запроса, потому что
ссылаются на значения из него. Помимо этого коррелированные запрос выполняется
для каждого значения из родительского набора данных.

Подзапросы могут участвовать как в инструкции select, так и в инструкциях
update, delete, insert.

### Подзапросы, возвращающие один столбец и несколько строк.

Подзапрос может вернуть несколько строк с одни столбцом и в таком случае его
нельзя использовать в условии равенства. Но существуют четыре оператора, которые
позволяют использовать такой подзапрос:

1) in;
2) not in;
3) all;
4) any.

#### Оператор in

Этот оператор может использоваться в условии проверки вхождения одного
единственного значения в множество значений, возвращенных подзапросом. К примеру
сделаем две таблицы, в одной будут значения 1, 2 и 3. А в другой будут 2, 3, 4,
а также 5. А теперь запросим такие значения из первой таблицы, которые
присутствуют и во второй:

```
mysql> select value from t1 where value in (select value from t2);
+-------+
| value |
+-------+
|     2 |
|     3 |
+-------+
```

Ответ именно такой, какой и следовало бы ожидать. Естественно, конкретно эту
задачу можно было бы решить и с применением оператора пересечения:

```
mysql> select value from t1 intersect select value from t2;
+-------+
| value |
+-------+
|     2 |
|     3 |
+-------+
```

Примененный подзапрос, в принципе, делает ровно то же самое, что и "where value
in (2, 3, 4)" или "where value = 2 of value = 3 or value = 4". Но применение
подзапроса выглядит куда лучше.

#### Оператор not in.

Оператор not in делает то же самое, что и in, но наоборот. Вот такие дела.

#### Оператор all.

Оператор all позволяет сравнить значение с целым набором значений. К примеру,
больше ли значение всех остальных значений в наборе. В сочетании с оператором
all следует применять операторы сравнения: <, >, != и так далее.

К примеру, для таблицы со значениями 1, 3, 5 можно выбрать только те значения,
которые меньше любого значения из таблицы со значениями 2, 4, 6 с помощью такого
запроса:

```
select value from t1 where value < all (select value from t2);
```

Задача: а что будет, если в множестве, с которым выполняется сравнение с
помощью операторов all или not in окажется null?

Вернется пустой набор. А происходит это по причине того, что СУБД сравнивает
значение слева с каждым из значений справа. А любая попытка сравнения c Null
приводит к Null.

```
mysql> select 1 > 2;    
+-------+
| 1 > 2 |
+-------+
|     0 |
+-------+

mysql> select 2 > 1; 
+-------+
| 2 > 1 |
+-------+
|     1 |
+-------+
1 row in set (0.00 sec)

+----------+
| 1 > null |
+----------+
|     NULL |
+----------+
```

#### Оператор any.

Оператор any похож на all, но результат его выполнения становится истиным только
в случае, если нашлось хотя бы одно значение в множестве, для которого
выполнилось условие. К примеру value больше хотя бы одного значения из (select
...)

Продемонстрируем это на таблицах содержащих числа 1, 10, 50:

```
mysql> select 1 where 1 > any (select value from t1);
Empty set (0.00 sec)

mysql> select 1 where 2 > any (select value from t1); 
+---+
| 1 |
+---+
| 1 |
+---+
```

1 меньше любого значения из таблицы t1. А вот 2 уже больше одного из значений
набора.

### Многостолбцовые подзапросы.

Многостолбцовые запросы могут быть использованы с операторами not in и in.
Просто сравнивать необходимо несколько столбцов с несколькими столбцами, которые
возвращает подзапрос.

### Коррелированные подзапросы.

Коррелированный подзапрос зависит от содержащей его инструкции, поскольку
ссылается на один или несколько её столбцов. Некоррелированный подзапрос
выполняется лишь один раз перед содержащей его инструкции, а вот коррелированный
напротив, выполняется каждый раз для строки- кандидата (строки, которая может
быть включена в результирующий набор).

В качестве демонстрации может быть рассмотрен такой пример:
Есть таблица, описывающая клиентов. В ней есть id и имя с фамилией каждого
клиента. Также существует таблица с записями о том, какой фильм брали клиенты с
перечислением их id. А есть задумка: вывести имена тех клиентов, которые брали
ровно 19 фильмов.

Задача может решаться по- разному. Можно соединить таблицы, сгруппировать по id,
отфильтровать тех, у кого count(*) в мини- табличке окажется равным 19 запросить
имена этих клиентов. С другой стороны можно обойтись и без соединения таблиц, а
с применением подзапроса. Нужно лишь, чтобы подзапрос возвращал количество
взятых напрокат фильмов для клиента с конкретным id.

Пожалуй, стоит привести пример подобного запроса:

```
select count(*) from rental where rental.customer_id = какой-то_конкретный_id;
```

Вот тут и становится понятно, что такое коррелированный подзапрос. Для
исполнения приведенного выше подзапроса необходим какой-то_конкретный_id,
единственный известный мне способ- предоставить его из родительского запроса.
Родительский запрос может выглядеть так:

```
select customer.first_name from customer;
```

Просто напросто запрашиваем строки из customer, тем самым получая и customer_id.
Теперь же соединим два запроса воедино:

```
mysql> select c.first_name from customer c where (select count(*) from rental r where r.customer_id = c.customer_id) = 19;
```

Рассмотрим другую ситуацию. Опять же есть таблица с клиентами. А также есть
таблица транзакций клиентов. В таблице транзакций собрана информация о том,
какой клиент, какую сумму оплачивал. Пускай опять есть задумка: запросить имена
тех клиентов, которые в итоге заплатили больше 100 у.е.

Сразу перейдем к делу: необходимо запрашивать имена из таблицы клиентов, а
затем, запрашивать сумму всех операций из таблицы транзакций для этого клиента.

```
mysql> select c.first_name from customer c where (select sum(p.amount) from payment p where p.customer_id = c.customer_id) > 100;
```

Ради разнообразия, решим эту задачу с помощью join.

```
mysql> select c.first_name from customer c inner join payment p using (customer_id) group by c.customer_id having sum(p.amount) > 100;
```

Оба этих запроса выдают одинаковый результат.

#### Оператор exists.

Оператор exists позволяет проверить, существует ли набор. Применение оператора
exists возвращает true в случае, если запрос (подзапрос) вернул не пустой набор.
К примеру:

```
mysql> select 1 where exists (select 1 where 1);
+---+
| 1 |
+---+
| 1 |
+---+
```

```
mysql> select 1 where exists (select 1 where 0);
Empty set (0.00 sec)
```

Рассмотрим более реалистичный случай. Пусть имеется таблица клиентов. А также
имеется таблица, в которой собрана информация о том, какой клиент какой фильм на
прокат взял. Задумка состоит в том, что есть желание найти таких клиентов,
которые взяли фильм на прокат до 25.05.2005.

Решение такой задачки через оператор exists состоит в следующем: необходимо
добавлять в итоговый набор таких клиентов, для которых существует набор фильмов,
которые они взяли на прокат до 25.05.2005.

```
mysql> select c.first_name from customer c where exists (select 1 from rental r where date(r.rental_date) < '2005-05-25' and r.customer_id = c.customer_id);
```

Попробуем решить другую задачку. Нам необходимо найти всех актеров, которые не
снимались в фильмах с рейтингом R. Для этого необходимо добавлять имена актеров
из таблицы актеров, если для них не существует набора фильмов с рейтингом R.

```
mysql> select a.first_name from actor a where not exists (select 1 from film f inner join film_actor fa using (film_id) where fa.actor_id = a.actor_id and f.rating = 'R');
+------------+
| first_name |
+------------+
| JANE       |
+------------+
```

### Работа с данными при помощи коррелированных подзапросов

Алан Болье утверждает о том, что коррелированные запросы чаще встречаются в
инструкциях update и delete. К примеру, с помощью такого запроса можно увеличить
все значения в колонке в два раза:

```
mysql> update t1 set value = (select t1.value * 2);
```

Естественно, необходимо, чтобы подзапрос был скалярным. Иначе произойдет что- то
странное и Вселенная схлопнется.

В более приближенном к реальности примере попробуем обновить дату последнего
взятия в аренду фильма в таблице клиентов на дату последнего взятия фильма из
таблицы взятия фильмов :-).

```
mysql> update customer c set c.last_update = (select max(r.rental_date) from rental r where r.customer_id = c.customer_id);
```

Тут путника может подстерегать угроза. Если в таблице rental по какой- то
причине не окажется взятого на прокат фильма (как он тогда может быть клиентом),
то в поле last_update клиенту запихнется Null, поскольку подзапрос вернет пустой
набор (потому что клиент не будет числиться в таблице взятия фильмов). Лучше
держать это в голове, а еще лучше добавить проверку.

Проверка будет выражена через другой подзапрос. Который будет проверять
существование в таблице взятия фильмов записи с конкретным id клиента:

```
mysql> update customer c set c.last_update = (select max(r.rental_date) from rental r where r.customer_id = c.customer_id) where exists (select 1 from rental r where r.customer_id = c.customer_id);
```

Второй подзапрос проверяет наличие записей о клиенте в таблице взятия фильмов.
Если клиент брал фильм на прокат- он есть в этой таблице. Select в этом случае
возвращает набор, состоящий из такого числа единиц, сколько существует записей,
связанных с клиентом. На основании этого фильтруются строки- кандидаты из
таблицы customer.

### Применение подзапросов.

Использование подзапросов не ограничивается только лишь нахождением условия для
удаления или выборки чего- нибудь. Помимо этого подзапросы возможно с успехом
применять в качестве инструмента для создания таблиц и генерации значений.

#### Подзапросы как источники данных.

Как мы помним, предложение from определяет тот набор таблиц, который будет
использоваться для дальнейшей обработки. Но вообще- то помимо таблиц как таковых
можно использовать и результаты подзапроса. Лишь бы он что- то возвращал. А вот
то, что возвращает подзапрос, уже может быть использовано как полноценная
таблица. Главное- навесить псевдоним.

Допустим, задачка: запросить имена и фамилии клиентов, а также число фильмов,
которые они брали напрокат и общую сумму денег, полученную от них. Две последнии
информации хранятся в таблице payment, первые две в customer. Их связывает
customer_id и его вполне можно было бы использовать для решения такой задачки:

```
mysql> select c.first_name, c.last_name, count(*) num_rentals, sum(p.amount) total_payments from customer c inner join payment p using (customer_id) group by c.customer_id;
```

Но также эту задачу можно решить с применением подзапроса:

```
mysql> select c.first_name, c.last_name, pmnts.num_rentals num_rentals, pmnts.total_payments total_payments from customer c inner join (select p.customer_id, count(*) num_rentals, sum(amount) total_payments from payment p group by customer_id) pmnts using (customer_id);
```

Подзапрос формирует таблицу из интересующих нас полей в таблице payment, а также
с ключом customer_id, по которому то мы и можем связать две таблицы.

Важное упоминание: подзапросы, применяемые в предложении from должны быть
некоррелированными. При выполнении главного запроса СУБД сперва выполнит
подзапросы, чтобы получить исходные наборы данных и сохранит их в оперативной
памяти. А это в свою очередь означает, что когда будет, допустим, происходить
изменение данных, на которые ссылаются коррелированные подзапросы- условия не
будут динамически изменяться. Да и вообще страшно подумать о том, что произойдет
при попытке менять данные во время их использования для составления неких
условий. Это почти как итерироваться по динамическому массиву и параллельно его
в размерах менять, только хуже.

Использование коррелированных подзапросов вроде как запрещено на уровне СУБД. Но
некоторые СУБД позволяют все таки их применять через cross apply или external
apply или еще что- нибудь в таком духе.

#### Подзапросы для создания данных.

Помимо того, чтобы тем или иным образом комбинировать существующие данные, с
помощью подзапросов можно нагенерировать таких данных, которые нельзя получить
никаким иным способом из базы данных.

К примеру, захотели мы распределить клиентов по группам. А группы мы еще и сами
понапридумывали. Сделать это мы можем с помощью трех селектов и парочки объединений.

```
mysql> select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit;
+---------------+-----------+------------+
| name          | low_limit | high_limit |
+---------------+-----------+------------+
| Small Fry     |         0 |      74.99 |
| Average Joes  |        75 |     149.99 |
| Heave Hitters |       150 | 9999999.99 |
+---------------+-----------+------------+
```

Что мы сделали? Мы сделали три селекта, каждый из которых вернул нам таблицу из
одной строки с тремя столбцами. Далее благодаря объединению мы их запихнули в
одну таблицу (нельзя забывать о том, что union работает лишь с таблицами с
равным числом колонок).

А теперь, раз у нас появилась такая чудесная таблица с группами, можно её
использовать с другими данными. Найдем распределение по группам всех клиентов:

```
mysql> select payment_groups.name, count(*) num_customers from (select customer_id, sum(amount) from payment group by customer_id) payments inner join (select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit) payment_groups on payments.customer_id between payment_groups.low_limit and payment_groups.high_limit group by payment_groups.name;
+---------------+---------------+
| name          | num_customers |
+---------------+---------------+
| Small Fry     |            74 |
| Average Joes  |            75 |
| Heave Hitters |           450 |
+---------------+---------------+
```

```
select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit
```

Запрос выглядит страшно, но все таки разберемся с ним. Сперва поймем, что мы
вообще хотим. А хотим мы получить название группы и число клиентов, которые туда
попали. Таким образом в изначальном select'е точно будем запрашивать название
группы name из таблицы, формируемой подзапросом, описанным выше, а также будем
вызывать функцию sum(). Ну и еще будем группировать, но об этом позже.

Значит, точно в from пишем подзапрос, формирующий группы:

```
mysql> select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit;
+---------------+-----------+------------+
| name          | low_limit | high_limit |
+---------------+-----------+------------+
| Small Fry     |         0 |      74.99 |
| Average Joes  |        75 |     149.99 |
| Heave Hitters |       150 | 9999999.99 |
+---------------+-----------+------------+
```

Этого не достаточно, далее мы получить таблицу содержащуюю потраченные деньги по
клиентам. То есть необходимо подзапросить сумму всех оплат из таблицы payment,
группированную по клиентам:

```
mysql> select sum(amount) total_payment from payment group by customer_id;
+---------------+
| total_payment |
+---------------+
|        118.68 |
|        128.73 |
.
.
.
|         83.78 |
|         83.81 |
+---------------+
599 rows in set (0.01 sec)
```

Теперь необходимо использовать "прикол" и соединить полученные таблицы на
основании не равенства как такового, а на основании принадлежности к диапазону:

```
mysql> ... (первый запрос) название1 inner join (второй запрос) название2 on название2.total_payments between название1.low_limit and название1.high_limit;
+---------------+-----------+------------+---------------+
| name          | low_limit | high_limit | total_payment |
+---------------+-----------+------------+---------------+
| Average Joes  |        75 |     149.99 |        118.68 |
| Average Joes  |        75 |     149.99 |        128.73 |
.
.
.
| Average Joes  |        75 |     149.99 |         83.81 |
+---------------+-----------+------------+---------------+
599 rows in set (0.02 sec)
```

Отлично, теперь остается лишь разбить это по группам и посчитать количество в
каждой группе. select название1.name, count(*) ... group by название1.name

#### Подзапросы, ориентированные на задачу.

Допустим, есть задачка: запросить имена, фамилии, а также общее количество денег,
которые принесли клиенты и количество фильмов, взятых ими напрокат. Задачку
можно решить, соединив несколько таблиц, а именно customer и payment. Их
необходимо соединить и разбить по группам:

```
mysql> select c.first_name, c.last_name, sum(p.amount) total_payments, count(*) total_rentals from customer c inner join payment p using (customer_id) group by c.first_name, c.last_name;
```

Можно поступить иначе. Через подзапрос сформировать таблицу значений с
cusotmer_id, общей суммой потраченных средств и числом взятых напрокат фильмов.
А затем соединить эти две таблицы воедино:

```
mysql> select c.first_name, c.last_name, pmnts.total_payments, pmnts.total_rentals from customer c inner join (select customer_id, sum(amount) total_payments, count(*) total_rentals from payment group by customer_id) pmnts using (customer_id) group by customer_id;
```

Второе решение задачки предпочтительнее по скорости выполнения по причине
выполнения группировки по числовому столбцу, а не по нескольким строковым.

#### Обобщенные табличные выражения. CTE.

CTE или Common table expressions появились в восьмой версии MySQL и являются
подзапросами. Внешней особенностью их является то, что они запрашиваются с
использованием предложения with. А помимо этого каждый вложенный подзапрос
обладает возможностью обращаться к значениям из родительского подзапроса. Такая
цепочка разделения области видимости реализуется в рамках одного with. Еще автор
утверждает, что так подзапросы становятся проще для зрительного восприятия.

Чтобы продемонстрировать CTE, реализуем запрос, который возвращает id и имя
клиента, но эту информацию он будет брать из CTE:

```
mysql> with id_name as (select customer_id id, first_name name from customer) select id, name from id_name;
+-----+-------------+
| id  | name        |
+-----+-------------+
|   1 | MARY        |
|   2 | PATRICIA    |
|   3 | LINDA       |
```

Теперь добавим еще один подзапрос, который будет коррелировать с родительским и
возвращать лишь те строки, в которых id в пределах от 10 до 15:

```
mysql> with id_name as (select customer_id id, first_name name from customer), filtered_id_name as (select id, name from id_name where id between 10 and 25) select id, name from filtered_id_name;
+----+---------+
| id | name    |
+----+---------+
| 10 | DOROTHY |
| 11 | LISA    |
| 12 | NANCY   |
| 13 | KAREN   |
| 14 | BETTY   |
| 15 | HELEN   |
+----+---------+
```

Как было продемонстрировано, второй CTE получает возможность обращаться к
первому, а внутри основного запроса все эти CTE становятся виртуальными
таблицами, доступными в предложении from.

#### Подзапросы как генераторы выражений.

Чуть ранее мы решали задачку о выборке имен, фамилий, общей суммы потраченных
клиентами денег и числом фильмов, которые они взяли напрокат. Мы решили эту
задачку двумя способами. В первом случае произвели соединение всего и вся в одну
здоровенную таблицу, затем прогруппировали по имени и фамилии, параллельно
высчитывая агрегатные функции.

Во втором случае мы сформировали через подзапрос значения суммы платежей и числа
взятых напрокат фильмов для каждого конкретного customer_id, а затем произвели
соединение.

Существует и третий вариант решения этой задачи (как мы помним, если существует
один алгоритм, приводящий к успеху- существует и бесконечное множество других
способ достичь того же результата). Так вот, третий способ заключается в том,
чтобы с помощью скалярных запросов вычислять значения колонок для каждого
customer_id. Примерно как тут:

```
mysql> select (select first_name from customer cus where cus.customer_id = c.customer_id ) name from customer c limit 2;
+----------+
| name     |
+----------+
| MARY     |
| PATRICIA |
```

Теперь провернем такой же трюк, но со всеми колонками, интересующими нас в
результирующем наборе:

```
mysql> select (select c.first_name from customer c where c.customer_id = p.customer_id) first_name, (select c.last_name from customer c where c.customer_id = p.customer_id) 
last_name, sum(amount) total_payments, count(*) total_rentals from payment p group by customer_id;
```

Этот запрос вернет анологичный результирующий набор.

### Заключение о подзапросах.

В заключение стоит подытожить:
1) Подзапросы бывают коррелированными и некоррелированными. Коррелированным
   подзапросом называется такой, внутри которого указано значение из
   обрамляющего запроса;
2) Подзапросы могут возвращать одно единственное значение и в таком случае они
   называются скалярными. Могут возвращать таблицу, состояющую из одной колонки
   и многих строк, в таком случае их удобно использовать с специальными
   операторами in, not in, exists и not exists, а также all.
3) Подзапросы можно запихнуть в Common Table Expression (CTE), чтобы получить
   возможность красиво создавать временные таблицы и обращаться к ним по мере
   необходимости.

## Соединения.

### Внешнее соединение.

Соединения бывают разные и пока что мне удалось поработать лишь с одни видом
соединений, а именно с внутренним соединением.

В базе данных, которую я использую, существует две таблицы: film и inventory. В
таблице film содержится 1000 строк, а в таблице inventory уникальных id фильмов
лишь 958. При использовании inner join при соединении этих двух таблиц в набор
попадут лишь 958 строк. Чтобы убедиться в этом, напишем следующего вида запрос:

```
mysql> select f.film_id, count(i.inventory_id) from film f inner join inventory i using (film_id) group by film_id;
|     998 |        2 |
|     999 |        5 |
|    1000 |        8 |
+---------+----------+
958 rows in set (0.00 sec)
```

А получается, что некоторые фильмы из таблицы film не попали в результирующий
набор, а именно целых 1000 - 958 = 42 штуки.

Запрос отбросил 42 фильма по причине того, что в inventory.film_id не оказалось
значения из колонки film.film_id. Эту ситуацию можно исправить, если применить
внешнее соединение:

```
mysql> select f.film_id, count(i.inventory_id) from film f left outer join inventory i using (film_id) group by film_id;
+---------+-----+
| film_id | cnt |
+---------+-----+
|      14 |   0 |
.
.
.
|     973 |   8 |
|    1000 |   8 |
+---------+-----+
1000 rows in set (0.01 sec)
```

Теперь запрос возвращает 1000 строк, причем тем фильмам, которые раньше
отбрасывалиcь, назначается 0 в столбце числа доступных для проката копий.
Происходит это потому что фильма с id, к примеру 14, нет в таблице inventory,
значит и число копий для него 0.

```
mysql> select * from inventory where film_id = 14;               
Empty set (0.00 sec)
```

Применение left outer по сравнению с inner привело к тому, что СУБД стала
добавлять в итоговый набор все строки из таблицы из левой части выражения
соединения и включения столбцов из правой стороны выражения. Другими словами:
СУБД запихнула строку из таблицы film, для которой нет информации в таблице
inventory. То есть нет столбцов именно правой таблицы. Получается, что СУБД
нарисовала столбцы правой таблицы для строки из левой таблицы.

Чтобы нагляднее посмотреть, что происходит, запросим id фильмов в диапазоне от
13 до 15 из таблицы film, их названия и инвентарные номера из таблицы inventory
при внутреннем соединении:

```
mysql> select f.film_id, f.title, i.inventory_id from f inner join inventory i using(film_id);
+---------+--------------+--------------+
| film_id | title        | inventory_id |
+---------+--------------+--------------+
|      13 | ALI FOREVER  |           67 |
|      13 | ALI FOREVER  |           68 |
|      13 | ALI FOREVER  |           69 |
|      13 | ALI FOREVER  |           70 |
|      15 | ALIEN CENTER |           71 |
|      15 | ALIEN CENTER |           72 |
|      15 | ALIEN CENTER |           73 |
|      15 | ALIEN CENTER |           74 |
|      15 | ALIEN CENTER |           75 |
|      15 | ALIEN CENTER |           76 |
+---------+--------------+--------------+
10 rows in set (0.00 sec)
```

А теперь провернем ту же самую процедуру, но при внешнем левом соединении:

```
mysql> select f.film_id, f.title, i.inventory_id from film f left outer join inventory i using (film_id) where f.film_id between 13 and 15;      
+---------+----------------+--------------+
| film_id | title          | inventory_id |
+---------+----------------+--------------+
|      13 | ALI FOREVER    |           67 |
|      13 | ALI FOREVER    |           68 |
|      13 | ALI FOREVER    |           69 |
|      13 | ALI FOREVER    |           70 |
|      14 | ALICE FANTASIA |         NULL |
|      15 | ALIEN CENTER   |           71 |
|      15 | ALIEN CENTER   |           72 |
|      15 | ALIEN CENTER   |           73 |
|      15 | ALIEN CENTER   |           74 |
|      15 | ALIEN CENTER   |           75 |
|      15 | ALIEN CENTER   |           76 |
+---------+----------------+--------------+
11 rows in set (0.00 sec)
```

Появлилась строчка с фильмом с id 14. А его инвентарный номер значится как null.
Это произошло потому что, для этого фильма нет информации в этой колонке в
таблице inventory (как и для любой другой колонки). В этой ситуации не
выполнилось условие соединения, что бы это не значило, а в таком случае все
столбцы, извлеченные из внешне соединенной таблицы будут нести значение null.

### Левые и правые соединения.

Ключевое слово left показывает, что таблица в левой части выражения отвечает за
количество строк в результирующем наборе, а таблица из правой части отвечает за
предоставление значений столбцов. Либо null.

Возможно заменить left на right и ситуация симметрично изменится. Правая таблица
будет отвечать за число строк, а левая за значения в столбцах:

```
mysql> select f.film_id, f.title, i.inventory_id from inventory i right outer join film f using (film_id) where f.film_id between 13 and 15;
+---------+----------------+--------------+
| film_id | title          | inventory_id |
+---------+----------------+--------------+
|      13 | ALI FOREVER    |           67 |
|      13 | ALI FOREVER    |           68 |
|      13 | ALI FOREVER    |           69 |
|      13 | ALI FOREVER    |           70 |
|      14 | ALICE FANTASIA |         NULL |
|      15 | ALIEN CENTER   |           71 |
|      15 | ALIEN CENTER   |           72 |
|      15 | ALIEN CENTER   |           73 |
|      15 | ALIEN CENTER   |           74 |
|      15 | ALIEN CENTER   |           75 |
|      15 | ALIEN CENTER   |           76 |
+---------+----------------+--------------+
11 rows in set (0.00 sec)
```

Замечание состоит в том, что в обоих случаях сервер выполняет соединение таблиц.
Ключевые слова left и right лишь дают понять СУБД о том, в какой таблице может
не доставать данных. Данных больше в левой- значит left outer, больше в правой-
right outer.

Не все СУБД поддерживают right outer join, так что автор рекомендует
использовать только left outer join. Помимо этого outer является еще и
необязательным словом, так что его можно и не использовать, но автор так делать
не рекомендует.

### Трехсторонние внешние соединения.

Возможно соединять и более двух таблиц используя внешнее соединение. Чтобы к
предыдущему запросу пристыковать еще и колонку последнего взятия фильма в
прокат, присоединим и таблицу rental:

```
mysql> select f.film_id, f.title, count(i.inventory_id), max(r.rental_date) from film f left join inventory i using (film_id) left join rental r using (inventory_id) group by f.film_id having f.film_id between 13 and 15; 
+---------+----------------+-----------------------+---------------------+
| film_id | title          | count(i.inventory_id) | max(r.rental_date)  |
+---------+----------------+-----------------------+---------------------+
|      13 | ALI FOREVER    |                     9 | 2006-02-14 15:16:03 |
|      14 | ALICE FANTASIA |                     0 | NULL                |
|      15 | ALIEN CENTER   |                    22 | 2005-08-23 19:21:22 |
+---------+----------------+-----------------------+---------------------+
```

Таким образом мы все состыковали, и получили интересующий нас результат.

### Перекрестные соединения.

Перекрестное соединение представляет собой декартово произведения. То все
возможные комбинации значений из таблиц. Продемонстрировать это стоит на простом
примере. Пусть есть таблицы t1 и t2. В таблице t1 хранятся значения 1, 2 и 3, а
в таблице t2 4, 5 и 6. Соединим их через cross join:

```
mysql> select * from t1 cross join t2 order by t1.value, t2.value;
+-------+-------+
| value | value |
+-------+-------+
|     1 |     4 |
|     1 |     5 |
|     1 |     6 |
|     2 |     4 |
|     2 |     5 |
|     2 |     6 |
|     3 |     4 |
|     3 |     5 |
|     3 |     6 |
+-------+-------+
9 rows in set (0.00 sec)
```

Чего и следовало ожидать, результирующий набор состоит из всех возможных
комбинаций значений таблиц t1 и t2.

Обычно говорят, будто перекрсестное соединение не особо полезно. Но Алан Болье
утверждает об обратном. Ранее мы уже использовали запрос для генерации таблицы с
тремя строками, представляющей собой категории клиентов. Вот этот запрос:

```
mysql> select 'Small Fry' name, 0 low_limit, 74.99 high_limit union select 'Average Joes' name, 75 low_limit, 149.99 high_limit union select 'Heave Hitters' name, 150 low_limit, 9999999.99 high_limit;
+---------------+-----------+------------+
| name          | low_limit | high_limit |
+---------------+-----------+------------+
| Small Fry     |         0 |      74.99 |
| Average Joes  |        75 |     149.99 |
| Heave Hitters |       150 | 9999999.99 |
+---------------+-----------+------------+
```

А что, если мы хотим провернуть подобный трюк, но создать таблицу с днями года?
В таком случае придется писать запрос на более чем три сотни строк, а это
утомительно. Вместо мы можем воспользоваться перекрестным соединением:

```
select ones.num + tens.num + hundreds.num days
from
(select 0 num union
select 1 num union
select 2 num union
select 3 num union
select 4 num union
select 5 num union
select 6 num union
select 7 num union
select 8 num union
select 9 num) ones
cross join
(select 0 num union
select 10 num union
select 20 num union
select 30 num union
select 40 num union
select 50 num union
select 60 num union
select 70 num union
select 80 num union
select 90 num) tens
cross join
(select 0 num union
select 100 num union
select 200 num union
select 300 num) hundreds
order by days;
```

Этот запрос вернет таблицу с одной колонкой days, в которой будут числа от 0 до
399. (10 возможных значений единиц * 10 возможных значений десятков * 4
возможных значений сотен = 400 значений).

Далее необходимо от набора чисел перейти к набору дат. А этого можно добиться
через применение функции date_add(), прибавляя числа к фиксированной дате,
например к 2021 году:

```
select date_add('2021-01-01', interval (ones.num + tens.num + hundreds.num) day) dt
from
(select 0 num union
select 1 num union
select 2 num union
select 3 num union
select 4 num union
select 5 num union
select 6 num union
select 7 num union
select 8 num union
select 9 num) ones
cross join
(select 0 num union
select 10 num union
select 20 num union
select 30 num union
select 40 num union
select 50 num union
select 60 num union
select 70 num union
select 80 num union
select 90 num) tens
cross join
(select 0 num union
select 100 num union
select 200 num union
select 300 num) hundreds
where date_add('2021-01-01', interval (ones.num + tens.num + hundreds.num) day) < '2022-01-01'
order by 1;
```

Этот запрос вернет таблицу, состоящую из дат за 2021 год. Автор содержит в тайне
правила синтаксиса для применения функции date_add, ну да ладно.

А что теперь с этим делать? А можно составить запрос, возвращающий информацию о
том, сколько фильмов в какой день было взято. Для этого нужно произвести внешнее
соединение с таблицей rental, сгруппировать по дням и посчитать число
rental_date.

```
select date_t.dt, count(rental.rental_date) from rental
right join
(select date_add('2005-01-01', interval (ones.num + tens.num + hundreds.num) day) dt
from
(select 0 num union
select 1 num union
select 2 num union
select 3 num union
select 4 num union
select 5 num union
select 6 num union
select 7 num union
select 8 num union
select 9 num) ones
cross join
(select 0 num union
select 10 num union
select 20 num union
select 30 num union
select 40 num union
select 50 num union
select 60 num union
select 70 num union
select 80 num union
select 90 num) tens
cross join
(select 0 num union
select 100 num union
select 200 num union
select 300 num) hundreds
where date_add('2005-01-01', interval (ones.num + tens.num + hundreds.num) day) < '2006-01-01') date_t
on date(rental.rental_date) = date_t.dt
group by date_t.dt
```

### Естественные соединения.

При использовании естественного соединения забота о том, как соединить таблицы
целиком и полностью основывается на СУБД. Ключевым словом для такого соединения
выступает natural join. Естественное соединение основывается идентичности имен
столбцов в нескольких таблицах. К примеру, в таблице rental есть столбец
customer_id, выступающий внешним ключом к таблице customer, где имеется
одноименный столбец, но выступающий уже в роли первичного ключа. А это
предоставляет возможность произвести естественное соединение:

```
mysql> select c.first_name, date(r.rental_date) from customer c natural join rental r;  
Empty set (0.04 sec)
```

Случилось что- то непонятное. Почему вернулся пустой набор? А ответ заключается
в том, что и в таблице customer, и в таблице rental присутствует по столбцу
last_update:

```
mysql> desc customer;
+-------------+-------------------+------+-----+-------------------+-----------------------------------------------+
| Field       | Type              | Null | Key | Default           | Extra                                         |
+-------------+-------------------+------+-----+-------------------+-----------------------------------------------+
| customer_id | smallint unsigned | NO   | PRI | NULL              | auto_increment                                |
| store_id    | tinyint unsigned  | NO   | MUL | NULL              |                                               |
| first_name  | varchar(45)       | NO   |     | NULL              |                                               |
| last_name   | varchar(45)       | NO   | MUL | NULL              |                                               |
| email       | varchar(50)       | YES  |     | NULL              |                                               |
| address_id  | smallint unsigned | NO   | MUL | NULL              |                                               |
| active      | tinyint(1)        | NO   |     | 1                 |                                               |
| create_date | datetime          | NO   |     | NULL              |                                               |
| last_update | timestamp         | YES  |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
+-------------+-------------------+------+-----+-------------------+-----------------------------------------------+
mysql> desc rental;
+--------------+--------------------+------+-----+-------------------+-----------------------------------------------+
| Field        | Type               | Null | Key | Default           | Extra                                         |
+--------------+--------------------+------+-----+-------------------+-----------------------------------------------+
| rental_id    | int                | NO   | PRI | NULL              | auto_increment                                |
| rental_date  | datetime           | NO   | MUL | NULL              |                                               |
| inventory_id | mediumint unsigned | NO   | MUL | NULL              |                                               |
| customer_id  | smallint unsigned  | NO   | MUL | NULL              |                                               |
| return_date  | datetime           | YES  |     | NULL              |                                               |
| staff_id     | tinyint unsigned   | NO   | MUL | NULL              |                                               |
| last_update  | timestamp          | NO   |     | CURRENT_TIMESTAMP | DEFAULT_GENERATED on update CURRENT_TIMESTAMP |
+--------------+--------------------+------+-----+-------------------+-----------------------------------------------+
```

СУБД производит объединение по customer_id, но также объединяет и по
last_update. По- сути делает это:

```
mysql> select c.first_name, date(r.rental_date) from customer c inner join rental r on c.customer_id = r.customer_id and r.last_update = c.last_update; 
Empty set (0.02 sec)
```

Единственным способом, позволяющим обойти такое огранчиение выступает
возможность ограничить столбцы как минимум в одной таблице, к примеру, через подзапрос:

```
mysql> select c.first_name, date(sr.rental_date) from customer c natural join (select rental_date, customer_id from rental) sr;
```

К счастью, Алан Болье глумится над этим способом соединения и призывает
использовать внутреннее соединение.

## Условная логика.

### Что такое условная логика?

Условная логика- возможность выбора одного из путей выполнения программы. Во
многих СУБД присутствуют свои операторы и функции для реализации условной
логики. К счастью стандарт SQL предлагает общий для всех оператор case.

К примеру имеем таблицу t1:

```
mysql> select * from t1; 
+-------+
| value |
+-------+
|     1 |
|     2 |
|     3 |
|     4 |
|     5 |
|     6 |
+-------+
```

Применим оператор case так, чтобы он в дополнительной колонке показывал, больше
или меньше число чем 3:

```
mysql> select value, case when value < 3 then 'Меньше трех' when value > 3 then 'Больше трех' else 'Равно трем' end what_about_3 from t1;
+-------+--------------+
| value | what_about_3 |
+-------+--------------+
|     1 | Меньше трех  |
|     2 | Меньше трех  |
|     3 | Равно трем   |
|     4 | Больше трех  |
|     5 | Больше трех  |
|     6 | Больше трех  |
+-------+--------------+
```

### Выражение case.

Большинство популярных СУБД предоставляют свои средства для реализации
конструкции if-then-else, к примеру decode() в Orcale, if() в MySQL, coalesce()
в Microsoft SQL Server.

Выражение case имеет свои преимущества перед упомянутыми выше:
1) CASE является частью стандарта SQL92;
2) CASE встроен в грамматику SQL и может быть использован в инструкциях select,
   insert, update и delete.

#### Поисковые выражения case.

Примененный ранее case оказался поисковым case. Case может возвращать не только
какое- то одно значение, но и результат выполнения скалярного подзапроса (может
быть его еще и во from можно использовать, а в этом случае case будет возвращать
и целый набор).

Синтаксис поискового выражения case выглядит так:

```
case
    when c1 then e1
    when c2 then e2
    ...
    when cn then en
    [else ed]
end
```

c1, c2, ..., cn - условия, e1, e2, ..., en - выражения, возвращаемые case. Если
ни оно из условий не выполнилось- вернется выражение ed, если оно указано,
иначе, null. **Важным ограничением выступает то, что все выражения e1, e2 и прочие
должны иметь один тип.**

#### Простые выражения case

Простое выражение похоже на поисковое. Синтаксис таков:

```
case v0
    when v1 then e1
    when v2 then e2
    ...
    when vn then en
    [else ed]
end
```

v0 - представляет собой значение, которое сравнивается со значениями v1 - vn.
Простые выражения case не являются такими гибкими, как поисковые по причине
того, что не представляется возможным указать собственное условие. Даже
вхождение в диапазон не применить. Просто сравнение одного значения на равенство
с другим.

Более приближенный пример к реальности:

```
case category.name
    when 'Action' then 'All ages'
    when 'Family' then 'All ages'
    else 'Other'
end
```

#### Преобразования результирующего набора. Pivot.

В приниципе, pivot означает "поменять строки и столбцы местами". Рассмотрим
такой запрос:

```
mysql> select monthname(rental_date) rental_month, count(*) num_rentals from rental where rental_date between '2005-05-01' and '2005-08-01' group by monthname(rental_date);
+--------------+-------------+
| rental_month | num_rentals |
+--------------+-------------+
| May          |        1156 |
| June         |        2311 |
| July         |        6709 |
+--------------+-------------+
```

Запрос возвращает три строки и два столбца. В первом столбце название месяца, а
во втором число взятых напрокат фильмов. Как можно перевернуть таблицу? Как
сделать таблицу из двух строк и трех столбцов? В этом может помочь выражение
case:

```
mysql> select sum(case when monthname(rental_date) = 'May' then 1 else 0 end) May, sum(case when monthname(rental_date) = 'June' then 1 else 0 end) June, sum(case when monthname(rental_date) = 'July' then 1 else 0 end) July from rental where rental_date between '2005-05-01' and '2005-08-01';
+------+------+------+
| May  | June | July |
+------+------+------+
| 1156 | 2311 | 6709 |
+------+------+------+
```

В измененном запросе мы запихиваем столбцы только те значения, которые произошли
в определенные месяцы. По всей видимости, только так можно сделать в MySQL для
переворачивания таблицы. А вот в Oracle Database и Microsoft SQL Server
существует предложение pivot специально для этого случая.

#### Проверка существования.

Хотим узнать, снимались ли актеры в фильмах с тем или иным рейтингом,
воспользуемся выражением case и попутно соединим таблицы actor, film_actor и film.

```
mysql> select a.first_name, a.last_name, case when exists(select 1 from film_actor inner join film using (film_id) where film_actor.actor_id = a.actor_id and film.rating = 'G') then 'Y' else 'N' end 'G_rating', case when exists(select 1 from film_actor inner join film using (film_id) where film_actor.actor_id = a.actor_id and film.rating = 'PG') then 'Y' else 'N' end PG_rating from actor a limit 5;
+------------+--------------+----------+-----------+
| first_name | last_name    | G_rating | PG_rating |
+------------+--------------+----------+-----------+
| PENELOPE   | GUINESS      | Y        | Y         |
| NICK       | WAHLBERG     | Y        | Y         |
| ED         | CHASE        | Y        | Y         |
| JENNIFER   | DAVIS        | Y        | Y         |
| JOHNNY     | LOLLOBRIGIDA | Y        | Y         |
+------------+--------------+----------+-----------+
```

В запросе выше мы проверяем наличие фильмов, для которых film_actor.actor_id
соответствует a.actor_id и рейтинг соответствует искомому.

#### Условные обновления.

```
mysql> update customer set active = case when 90 <= (select datediff(now(), max(rental_date)) from rental r where r.customer_id = customer.customer_id) then 0 else 1 end where active = 1;
```

Короче, если где- то можно использовать значение- case может с этим справиться.

## Транзакции.

Транзакция - механизм группировки набора инструкций SQL таким образом, чтобы они
либо выполнялись все, либо не выполнялись вообще.

### Блокировка

Блокировка - это механизм управления доступом к данным. Большинство серверов баз
данных используют одну из двух стратегий блокировки:

1) Писатели (пользователи, записывающие в БД) должны запросить и получить от
   сервера блокировку записи на таблицу или её часть прежде чем смогут
   осуществить запись. Читатели должны запрашивать и получать блокировку чтения.
   Множественное чтение не запрещено, несколько пользователей могут читать один
   и тот же кусок данных. Блокировка записи на таблицу или её часть выдается
   один раз. При блокировке записи не выдается блокировка чтения, то есть нельзя
   читать данные, которые другой пользователь изменяет.

Получается следующая ситуация: читать могут многие, изменять только один, а
читать пока кто- то изменяет нельзя.

2) Для писателей выдаются блокировки аналогично первой стратегии. Блокировок на
   чтение не существует, а вместо них читатели читают свои версии данных,
   полученные в момент начала чтения. Такая стратегия известна под названием
   управления версиям.

SQL Server использует первый подход, Oracle database использует второй. А MySQL
способен применять оба подхода.

### Гранулярность блокировок

Сервер может блокировать ресурс данных на одном мз трех уровней или
гранулярностей.

1) Блокировка таблиц;
2) Блокировка страниц;
3) Блокировка строк.

Блокировка таблиц распространяется целиком на тбалицу. Блокировка страниц
блокирует, что понятно, страницы- куски от таблицы, хранящий строки. Обычно от 2
до 16 Кбайт. А блокировка строк запрещает менять одну и ту же строку нескольким
пользователям.

### Что такое транзакция.

Через механизм транзакций, а именно через следующий из него принцип "все или
ничего" реализуется **атомарность**. Либо выполнятся все действия, которые
желает выполнить пользователь, либо не выполнится ни одно из них.

Например, процедуру перевода денежных средств с одного счета на другой можно
описать следующим образом:

```
START TRANSACTION

Уменьшить число денег на счет1 на 500;
Увеличить число денег на счет2 на 500;
IF все успешно, то COMMIT
ELSE ROLLBACK
```

В случае, если внутри транзакции что- то произошло не так- произойдет откат
изменений (на самом деле они просто не попадут в журнал предзаписи и тем более
не запишутся на постоянное хранилище в виде данных).

Выполнение COMMIT подтверждает транзакцию, но сервер может выключиться прежде
чем подтвердит её. При последующем запуске сервер почитает журнал WAL, определит
те транзакции, которые следует произвести и записать изменения на диск и сделает
это. Данное свойство зовется durability или устойчивостью.

### Запуск транзакции.

СУБД обрабатывает создание транзакций одним из двух способов.

1) Активная транзакция всегда связана с сеансом базы данных. Когда заканчивается
   одна транзакция, сервер автоматически начинает новую транзакцию для сеанса.
2) Если транзакция не начинается явно, каждая отдельная инструкция SQL счиатется
   совершенно независимой от другой. Чтобы объединить инструкции в одну
   транзакцию необходимо явно выполнить соответствующую команду.

Oracle использует первый способ, SQL Server и MySQL используют второй.

Стандарт sql2003 включает команду start transaction для указания явного
намерения начать транзакцию. В MySQL это так, но в SQL Server придумали другую
команду begin transaction.

### Завершение транзакции.

После того как транзакция началась, её необходимо завершить. Делается это при
помощи команды commit. Команда rollback отменяет изменения.

В некоторых случаях происходит автоматическое завершение транзакции. К примеру
при выключении сервера или при начале новой транзакции.

В случае изменения схемы БД (инструкция alter, создание новой таблицы или
удаление таблицы, а то и БД) сервер завершает текущую транзакцию, совершает
действия над схемой бд, а затем готов открыть новую транзакцию.

Еще сервер можно завершить транзакцию, если обнаружит взаимоблокировку и придет
к выводу о том, что именно моя транзакция виновна в этом.

Взаимоблокировка возникает когда одна транзакция намутила изменений в таблице 1
и ждет блокировки в таблице 2, а вторая транзакция успела намутить изменений в
таблице 2 и теперь ждет блокировки в таблице 1. Получается, что обе транзакции
ждут и всё тут.

Алан Болье интересный персонаж, сперва он пишет, что СУБД сама решает, кто
виновен в взаимной блокировке, а потом говорит о том, что СУБД наугад отменяет
одну из транзакций и дает завершиться другой. Правда, также он упоминает и о
том, что существуют некие критерии для того, чтобы не действовать наугад.

### Точки сохранения транзакций.

Внутри начатой транзакции возможно расставлять так называемые точки сохранения,
к которым возможно откатиться в случае необходимости.

Для этого необходимо ввести команду savepoint и указать имя точки сохранения.
Имя является обязательным полем.

```
savepoint my_savepoint;
```

Чтобы откатиться к точке осхранения используется уже знакомая команда rollback с
дополнением to savepoint 'название_точки_сохранения'

```
rollback to savepoint my_savepoint;
```

Если выполнить rollaback без указания точки сохранения- произойдет откат всей
транзакции целиком. То есть и точки сохранения будут утеряны.

## Индексы и ограничения.

### Индексы.

Индекс - механизм поиска конкретного объекта внутри ресурса. СУБД использует
индексы для быстрого нахождения строк в таблице. Индексы являются таблицами,
хранящимися в особом порядке. Вместо того, чтобы содержать все данные о
конкретной записи, индексы хранят лишь столбец или столбцы, используемые для
поиска строк в таблице с данными.

### Создание индекса.

Создание индекса происходит через инструкцию схемы alter table:

```
alter table customer add index idx_email (email);
```

В случае, если для таблицы задан индекс- оптимизатор сам разберется с тем, что и
как искать. Даже если существует несколько индексов для одной таблицы-
оптимизатор сам разберется, какой лучше использовать.

MySQL рассматривает индексы как необязательные компоненты таблицы, а потому в
ранних версиях добавление индекса было возможно только через alter table.
Начиная с версии 5 доступна команда create index, которая отображается в команду
alter table. Правда, для создания индекса первичного ключа по- прежнему
потребуется применение alter table.

Чтобы посмотреть информацию о наличии индекса у таблицы следует ввести следующую
команду: show index from 'название_таблицы'. Можно еще добавить ключ \G, который
делает непонятно что, что вывод расширяется.

Индексы иожно создавать и при создании таблицы:

```
mysql> create table t1 (value int, key idx_value (value)); 
Query OK, 0 rows affected (0.02 sec)
```

Помимо этого индекс автоматически генерируются для первичного ключа при создании
таблицы.

#### Уникальные индексы.

Уникальный индекс обладает теми же свойствами, что и обычный индекс, но вместе с
этим не позволяет дублироваться значениям в той колонке, на которую он был
применен.

Так можно добавить уникальный индекс к существующей таблице:

```
alter table 'название_таблицы' add unique 'название_индекса' ('имя_колонки');
```

А так можно задать уникальный индекс при создании таблицы:
```
mysql> create table t1 (value int, unique idx_value (value));
Query OK, 0 rows affected (0.02 sec)
```

#### Многостолбцовые индексы.

Многостолбцовые индексы имеет смысл использовать тогда, когда есть намерение в
будущем искать строки в таблице сразу по нескольким колонкам. Задается
многостолбцовый индекс также, как и обычный, просто в скобках указывается
перечисление используемых столбцов. К примеру, чтобы создать многостолбцовый
индекс по фамилии и имени, следует применить подобный синтаксис:

```
mysql> alter table customer add index idx_full_name (last_name, first_name);
```

Созданный индекс будет иметь смысл при поиске по фамилии. Еще больше смысла он
будет нести при поиске по фамилии и имени. А вот при поиске по имени от него не
будет никакой пользы. Таким образом, при задании многостолбцовых индексов
следует задумываться о том, в каком порядке лучше расположить столбцы.

### Типы индексов.

По причине существования многих типов данных, не существует оптимальной
стратегии их индексирования.

#### Индексы B-tree.

По- умолчанию и Oracle Database, и Microsoft SQL Server, и MySQL используют этот
тип индексирования- индекс на основе сбалансированного бинарного дерева.

Если бы я был лучше знаком с устройством бинарного дерева- возможно, этот
комментарий и не потребовался. Но за неимением другого, будем делать, что можем.

Суть в том, что данные разделяются на кусочки, листья. И хранятся в одном уровне
листовых узлов. К ним можно попасть из корневого узла, пройдясь по узлам
ветвления. К примеру, индекс для фамилий можно представить так:

```
1) Корневой узел имеет два пути: от А до П, и от Р до Я.
2) Узлы ветвления, в которые можно попасть из главного узла, допустим, ведут уже на четыре группы фамилий, начинающиеся с букв из неперсекающихся диапазонов.
3) В листях содержатся фамилии, по которым СУБД проходит сканирующим поиском.
```

Сбалансированным дерево называется потому что СУБД следит за тем, чтобы с одной
стороны корневого узла не оказалось больше значений, нежели с другой. Сервер
может добавлять и удалять узлы ветвления, а также добавлять и удалять целые
уровни узлов ветвления.

#### Битовые индексы.

B-tree индексы плохо показывают себя в случае, когда число возможных значений в
столбце мало. К примеру, в таблице на миллион пользователей есть колонка,
показывающая, активен ли пользователь. Значение в колонке может принимать только
0 и 1. Обычно, число активных ползователей меньше числа неактивных. В таком
случае СУБД просто не сможет провести никакую балансировку дерева.

Для столбцов с низкой кардинальностью (малое число значений при большом числе
строк) необходима другая стратегия индексирования и таковой выступает стратегия
битовых индексов.

MySQL, по всей видимости, так не умеет, но зато так умеет Oracle.

#### Текстовые индексы.

Тут следует смотреть в документацию по применению, но суть заключается в том,
что через этот индекс ускоряется поиск по документу, сохраненному в БД.

### Как используются индексы. Команда explain.

Рассмотрим следующий запрос:

```
mysql> select customer_id, first_name, last_name from customer where first_name like 'S%' and last_name like 'P%';
+-------------+------------+-----------+
| customer_id | first_name | last_name |
+-------------+------------+-----------+
|          84 | SARA       | PERRY     |
|         197 | SUE        | PETERS    |
|         167 | SALLY      | PIERCE    |
+-------------+------------+-----------+
```

Для этого запроса СУБД может воспользоваться любой из стратегий:
1) Сканировать все строки в таблице;
2) Использовать индекс в last_name, чтобы найти все строки, в которых фамилия
   начинается с P, затем посетить каждую строку, в которой имя начинается с S.
3) Использовать индекс для двух столбцов сразу.

Чтобы увидеть, как выполняется запрос, следует применить ключевое слово explain
перед инструкцией select:

```
mysql> explain select customer_id, first_name, last_name from customer where first_name like 'S%' and last_name like 'P%' \G; 
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: range
possible_keys: idx_last_name,idx_full_name
          key: idx_full_name
      key_len: 182
          ref: NULL
         rows: 28
     filtered: 11.11
        Extra: Using index condition; Using where
1 row in set, 1 warning (0.00 sec)
```

Значение possible_keys говорит о том, какие индексы могут быть использованы. А
значение в key говорит о том, какой индекс все таки будет использоваться.

### Обратная сторона индексов.

Почему нельзя проиндексировать все, что угодно? Потому что изменение строки,
будь то её добавление или удаление, ведет к изменению всех таблиц- индексов,
которые с ней связаны. А это увеличивает инфраструктурную нагрузку на СУБД.
Вкупе с возможностью добавлять индексы при необходимости и затем их удалять,
постяонное хранение и обслуживание индексов не считается оптимальным.

Общие рекомендации по индексации таковы:
1) Все первичные ключи должны быть проиндексированы. При наличии
   многостолбцового первичного ключа следует создать дополнительные индексы его
   подмножеств столбцов. Но в ином порядке.
2) Создавать индексы для всех столбцов на которые имеются ссылки внешних ключей.
   и по всей видимости, столбцы- внешние ключи, которые ссылаются.
3) Создавать индексы для тех столбцов, которые часто используются для извлечения
   данных. К примеру столбцы дат.

### Ограничения.

Ограничения- это просто условия, накладываемые на один или несколько столбцов
таблицы. Имеется несколько различных типов ограничений:
- Ограничение первичного ключа;
- Ограничение внешнего ключа;
- Ограничение уникальности;
- Проверочное ограничение.

Ограничение первичного ключа гарантирует уникальность значения в столбце или
совокупности значений столбцов.

Ограничение внешнего ключа определяет возможными для хранения в одном или
нескольких столбцах только такие значения, которые существуют с столбце
первичного ключа другой таблицы. Также могут ограничиваться допустимые значения
в других таблицах при установлении правил delete cascade или update cascade.

### Создание ограничения. update/delete restrict/cascade/set null.

Создаются ограничения при создании таблицы через constraint при перечислении
столбцов, после ключевого слова constrain идет название ограничения. Например
для ограничения на внешний ключ следует написать:

```
... constraint fk_value1 foreign key (value1) references another_table (value1)
```

К ограничению внешнего ключа возможно еще присоединить такую штку как 'ON DELETE
RESTRICT ON UPDATE CASCADE'

- on delete restrict приводит к тому, что при удалении родительского элемента
  генерируется ошибка, если на него ссылается дочерний элемент.
- on update cascade заставляет распространять изменения в первичном ключе
  родительской таблицы на дочернии элементы.

Помимо restrict и cascade возможно указать и set null. Такая модификация
приведет к тому, что в дочерних ссылающихся элементах при изменении и/или
удалении родительских элементов будет меняться значение на null.

### Удаление ограничений внешнего или первичного ключей.

Для этого необходимо выполнить alter table 'имя таблицы' drop ...

```
mysql> alter table rental drop constraint fk_customer_id;
```

## Представления.

В хороших системах, как правило, реализация не доступна снаружи для
пользователя, а вместо этого предоставлен интерфейс для вазимодействия.
Аналогичную фишку возможно провернуть и с базами данных. Возможно закрыть от
пользователя все таблицы, а вместо них представить набор представлений.

### Что такое представление.

Представление - это просто механизм запроса данных. Они не хранятся на диске как
таблицы. Представление создается путем присваивания инструкции select имени и
последующим сохранением. Другие пользователь затем могут воспользоваться
представлением для доступа к данным.

К примеру, есть потребность скрыть адреса электронной почты пользователей из
таблицы, разрешив лишь отдельной касте пользователей доступ к этим данным.
Решением выступает создание представления:

```
mysql> create view customer_vw (customer_id, first_name, last_name, email) as select customer_id, first_name, last_name, concat(substr(email,1,2), '*****', substr(email, -4)) email from customer;
Query OK, 0 rows affected (0.03 sec)

mysql> select first_name, last_name, email from customer_vw limit 3; 
+------------+-----------+-------------+
| first_name | last_name | email       |
+------------+-----------+-------------+
| MARY       | SMITH     | MA*****.org |
| PATRICIA   | JOHNSON   | PA*****.org |
| LINDA      | WILLIAMS  | LI*****.org |
+------------+-----------+-------------+
```

Представление создается через create view 'имя_представления'
(названия_столбцов) as 'запрос select'. Как можно заметить- после создания
представления, к нему возможно обратиться как к обычной таблице.

Представления даже показываются при запросе show tables:

```
mysql> show tables;
+----------------------------+
| Tables_in_sakila           |
+----------------------------+
...
| customer_list              |
| customer_vw                |
| film                       |
...
```

Получить информацию о строении представления возможно через команду desc.
Которая исползуется для этих же целей с таблицами.

### Зачем использовать представления

В основном для более гибкой настройки разграничения доступа: кому какие столбцы
видны или в каком виде выдается информация из строк. А также представления
удобно использовать для уменьшения сложности взаимодействия пользователя и СУБД.

### Обновляемые представления

Популярные СУБД разрешают менять данные через представления, но при условии, что
соблюдаются некоторые ограничения:
1) Не используются агрегатные функции;
2) Не используются group by и having;
3) Нет никаких подзапросов в select и from. А любой подзапрос в where не
   ссылается на таблицы из from;
4) Представление не использует union, union all или distinct.
5) Предложение from содержит как минимум одну таблицу или обновляемое
   представление;
6) Если используется более одной таблицы или представления, предложение from
   использует только внутренние соединения.

### Обновления простых представлений

Представления, если удволетворяют условиям, приведенным выше, могут быть
обновлены как обычные таблицы через update 'название_представления' set
'имя_колонки' = 'значение'.

А вот вставить значения в таблицу посредством представления нельзя.

## Метаданные

Метаданными зовется инофрмация о таблицах, представлениях, индексах и прочем
подобном. Сервер базы данных хранит эту инофрмацию в самой базе данных.

Сборищем информации о таблице, такой как её название, индексы, порядок
сортировки индексов, названия столбцов и так далее, зовется **словарь данных**
или **системный каталог**.

СУБД дает изменять эти данные только через соответствующий механизм, такой как
иснтрукция alter table.

### information_schema

information_schema - БД, которая хранит в себе всякие приколюхи. В том числе и
информацию о создаваемых пользователем БД.

К примеру, так можно получить информацию о таблицах из information_schema:

```
mysql> select * from information_schema.tables;
```

## Аналитические функции

Аналитические функции выступают инструментом обработки данных. Что- то где- то
посчитать, что- то где- то составить какой- то рейтинг и так далее.

### Концепции аналитических функций

После того, как сервер СУБД произвела соединение, фильтрацию, группировку и
сортировку, а значит и создала результирующий набор, существует возможность
присоединить к этому конвейеру невероятных чудес еще и дополнительную обработку.

### Окна данных

Допустим, хотим увидеть итоги продаж за каждый месяц в период с мая по август за
2005 год. Таким образом сделали запрос:

```
mysql> select quarter(payment_date) quarter, monthname(payment_date), sum(amount) from payment where year(payment_date) = 2005 group by quarter(payment_date), monthname(payment_date);
+---------+-------------------------+-------------+
| quarter | monthname(payment_date) | sum(amount) |
+---------+-------------------------+-------------+
|       2 | May                     |     4823.44 |
|       2 | June                    |     9629.89 |
|       3 | July                    |    28368.91 |
|       3 | August                  |    24070.14 |
+---------+-------------------------+-------------+
```

Глазами видно, что за второй квартал наибольшая прибыль пришлась на июнь, а за
третий квартал на июль. Но железка- то этого не поймет. Необходимо как- то её
заставить вывести значения максимальной прибыли за все четыре месяца и
максимальной прибыли по кварталам.

Для этого придется переписать запрос, добавив парочку новых столбцов:

```
mysql> select quarter(payment_date) quarter, monthname(payment_date), sum(amount), max(sum(amount)) over () max_overall_sales, max(sum(amount)) over (partition by quarter(payment_date)) max_qrtr_sales from payment where year(payment_date) = 2005 group by quarter(payment_date), monthname(payment_date);
+---------+-------------------------+-------------+-------------------+----------------+
| quarter | monthname(payment_date) | sum(amount) | max_overall_sales | max_qrtr_sales |
+---------+-------------------------+-------------+-------------------+----------------+
|       2 | May                     |     4823.44 |          28368.91 |        9629.89 |
|       2 | June                    |     9629.89 |          28368.91 |        9629.89 |
|       3 | July                    |    28368.91 |          28368.91 |       28368.91 |
|       3 | August                  |    24070.14 |          28368.91 |       28368.91 |
+---------+-------------------------+-------------+-------------------+----------------+
```

Что произошло я сам не до конца понимаю. Точно известно, что мы добавили два
столбца:
1) max(sum(amount)) over () max_overall_sales
2) max(sum(amount)) over (partition by quarter(payment_date)) max_qrtr_sales

Первый добавленный столбец, как мы можем предположить, содержит максимальное
значение выражения sum(amount) по всей таблице (over()). Второй столбец чуть
хитрее и содержит максимальное значение суммы, но за весь квартал.

То, что мы намутили, зовется аналитическими функциями. Для этого вида анализа
аналитические функции предлагают возможность группировки строк в окна, позволяя
производить рассчет лишь над окном, не затрагивая другие значения
результирующего набора. Окна определяются с применением предложения over в
сочетании с необязательной конструкцией partition by. Окно может содержать от
одной строки до всех строк из результирующего набора.

#### Сортировка внутри окна

Вместе с возможностью разделения результирующего набора на окна данных,
существует возможность указания порядка сортировки внутри окна. Реализовать эту
функцию возможно с применением функции rank() над окном.

#### Функции ранжирования

Функции ранжирования позволяют осуществлять ранжирование: топ 10, топ 1 и так
далее.

row_number() - возвращает для каждой строки уникальное число с произвольно
назначаемым рейтингом для одинаковых данных.

rank() - возвращает при одинаковых данных одинаковый рейтинг с пропусками в
общем рейтинге.

dense_rank() - возвращает при одинаковых именах один и тот же рейтинг без
пропусков в общем рейтинге.

#### Рамки окон

Рамки окон, в которых выполняются аналитические функции задаются предложением
partition by внутри over(). Но также можно сделать и плавающее окно, с одной
стороны будет фиксировано какой- то константой, а с другой ограничиваться
текущей строкой.

```
mysql> select yearweek(payment_date) payment_week, sum(amount) week_total, sum(sum(amount)) over (order by yearweek(payment_date) rows unbounded preceding) rolling_sum from payment group by yearweek(payment_date) order by 1;
+--------------+------------+-------------+
| payment_week | week_total | rolling_sum |
+--------------+------------+-------------+
|       200521 |    2846.19 |     2846.19 |
|       200522 |    1977.25 |     4823.44 |
|       200524 |    5603.43 |    10426.87 |
|       200525 |    4026.46 |    14453.33 |
|       200527 |    8490.83 |    22944.16 |
|       200528 |    5982.64 |    28926.80 |
|       200530 |   11027.23 |    39954.03 |
|       200531 |    8412.07 |    48366.10 |
|       200533 |   10619.11 |    58985.21 |
|       200534 |    7907.17 |    66892.38 |
|       200607 |     514.18 |    67406.56 |
+--------------+------------+-------------+
```

Вот это вот rows unbounded preceding означает, что окно начинается от начала
результирующего набора и заканчивается текущей строкой.

## **А теперь про оконные функции с ХАБРа**

Оконная функция - функция, которая работает с выделенным набором строк (окном,
партицией), выполняет вычисление для этого набора и выводит результат в
отдельном столбце.

Партиция (окно) - это набор строк, указанный для оконной функции по одному
столбцу или группе столбцов.

### В чем заключается отличие оконных функций от функций с агрегацией и группировкой?

Использование агрегирующих функций ведет к уменьшению числа строк в
результирующем наборе, а использование оконных функций не ведет к уменьшению
строк, вместо этого увеличивается число столбцов.

### Синтаксис оконных функций

```
FUNCTION_NAME(column_name) over (partition by(column_names) order by(column_names))
```

### Классы оконных функций

Оконные функции можно разделить на 3 класса:

- Агрегирующие
- Ранжирующие
- Функции смещения

#### Агрегирующие функции

Агрегирующие носят такое название поскольку подразумевают использование любой из
агрегирующих функций: max, min, count, sum, avg.

Заранее была создана таблица такого вида:

```
mysql> select * from student_grades;
+------+------------+-------+
| name | subject    | grade |
+------+------------+-------+
| Петя | русский    |     4 |
| Петя | физика     |     5 |
| Петя | история    |     4 |
| Маша | математика |     4 |
| Маша | русский    |     3 |
| Маша | физика     |     5 |
| Маша | история    |     3 |
+------+------------+-------+
```

Если мы хотим запросить средний бал ученика, мы можем сделать это через
группировку и агрегацию:

```
mysql> select name, avg(grade) from student_grades group by name;
+------+------------+
| name | avg(grade) |
+------+------------+
| Петя |     4.3333 |
| Маша |     3.7500 |
+------+------------+
```

А можно воспользоваться оконной функцией:

```
mysql> select name, avg(grade) over (partition by name) from student_grades;
+------+-------------------------------------+
| name | avg(grade) over (partition by name) |
+------+-------------------------------------+
| Маша |                              3.7500 |
| Маша |                              3.7500 |
| Маша |                              3.7500 |
| Маша |                              3.7500 |
| Петя |                              4.3333 |
| Петя |                              4.3333 |
| Петя |                              4.3333 |
+------+-------------------------------------+
```

Как можно увидеть, число строк не уменьшилось, их как было 7 в изначальном
наборе, так столько и осталось.

#### Ранжирующие функции

Существует три вида ранжирующих функций:

- row_number()
- rank()
- dense_rank()

При использовании ранжирующей функции обязательно указывать уловие order by,
именно по нему будет происходить ранжирование.

По сути ранжирующие функции занимаются тем, что выдают числовое значение строкам
в зависимости от того, на каком месте они находятся после сортировки по условию,
указанному в order by. Но только делают это немного по разному.

> row_number()

row_number() выдает порядковый номер вне зависимости от того, есть ли в строках
повторяющиеся значения:

```
mysql> select name, subject, grade, row_number() over (partition by name order by grade desc) row_num from student_grades order by name;
+------+------------+-------+---------+
| name | subject    | grade | row_num |
+------+------------+-------+---------+
| Маша | физика     |     5 |       1 |
| Маша | математика |     4 |       2 |
| Маша | русский    |     3 |       3 |
| Маша | история    |     3 |       4 |
| Петя | физика     |     5 |       1 |
| Петя | русский    |     4 |       2 |
| Петя | история    |     4 |       3 |
| Петя | физика     |     3 |       4 |
+------+------------+-------+---------+
```

Мы выяснили, что ранжирование позволяет отсортировать строки внутри своих
группок. В частности, окон. Вот, что мы и видим: Окна ограничены именами
студентов. Одно имя- одно окно. В рамках таблицы окошки отсортированы по имени
студента, а вот уже внутри происходит сортировка по оценке. В следствие
сортировки по оценки функция row_number и раскидала ранги на основании порядка
сортировки. Ранги могут дублироваться в разных окнах, но в одном при
использовании row_number- ни за что.

> rank()

rank() выдает значения аналогично row_number за тем исключением, что
повторяющимся строкам выдается одинаковый ранг. Но зачем- то пропускается
следующее значение. Это можно увидеть на примере Пети: русский и история имеют
ранг 2. А вот физика уже 4.

```
mysql> select name, subject, grade, rank() over (partition by name order by grade desc) rank_value from student_grades order by name;
+------+------------+-------+------------+
| name | subject    | grade | rank_value |
+------+------------+-------+------------+
| Маша | физика     |     5 |          1 |
| Маша | математика |     4 |          2 |
| Маша | русский    |     3 |          3 |
| Маша | история    |     3 |          3 |
| Петя | физика     |     5 |          1 |
| Петя | русский    |     4 |          2 |
| Петя | история    |     4 |          2 |
| Петя | физика     |     3 |          4 |
+------+------------+-------+------------+
```

> dense_rank()

dense_rank() производит ранжирование так, как и rank(), но не пропускает
следующее значение при встрече с дубликатами:

```
mysql> select name, subject, grade, dense_rank() over (partition by name order by grade desc) danse from student_grades order by name;
+------+------------+-------+-------+
| name | subject    | grade | danse |
+------+------------+-------+-------+
| Маша | физика     |     5 |     1 |
| Маша | математика |     4 |     2 |
| Маша | русский    |     3 |     3 |
| Маша | история    |     3 |     3 |
| Петя | физика     |     5 |     1 |
| Петя | русский    |     4 |     2 |
| Петя | история    |     4 |     2 |
| Петя | физика     |     3 |     3 |
+------+------------+-------+-------+
```

#### Функции смещения

Их две:

- lag()
- lead()

> lag()

lag() возвращает значение из предыдущей строки

> lead()

lead() возвращает значение из следующей строки

## Работа с большими базами данных

### Секционирование

Сеционирование- процесс разделения таблицы на части при её создании.
Секционирование позволяет уменьшить число проблем, связанных с излишним объемом
таблицы, возникающих при выполнии таких задач, как:
- выполнение запросов, требующих полного сканирования таблицы;
- создание/восстановление индексов;
- архивирование/ удаление данных;
- создание статистик таблиц/индексов;
- перенос таблицы (например, в другое табличное пространство);
- резервное копирование базы данных.

#### Концепции секционирования

Когда таблица секционируется- создаются две или более таблиц- разделов, каждая
из которых имеет такое же определение, но данные, хранящися в таблицах не
пересекаются. К примеру можно провести секционирование по месяцам.

После секционирования таблица представляет собой виртуальную концепцию. По сути
она перестает быть таблицей, но пользователь из вне может продолжать работу с
ней так, будто ничего и не поменялось. Данные из таблицы хранятся в отдельных
местах, индексы строятся отдельно для каждой из секций. При этом существует
некоторые административные возможности, берущие во внимание то, что таблица все
таки секционирована:
- разделы могут храниться в разных табличных пространствах, которые находятся на
  разных физических хранилищах;
- разделы могут быть сжаты;
- локальные индексы могут отстутствовать для отдельных разделов;
- статистика таблицы для некоторых разделов может быть заморожена, при этом
  обновляясь для других;
- отдельные разделы могут быть закреплены в памяти или храниться на
  флеш-хранилище.

#### Секционирование таблицы

Обычно секционирование имеет вид горизонтального секционирования. Это означает,
что в тот или иной раздел строки попадают целиком. При таком типе
секционирования необходимо выбрать ключ секционирования, представляющий собой
один из столбцов функции, реже несколько столбцов. Секционирование будет
производиться на основании значения этого столбца. Помимо горизонтального
секционирования существует и веритикальное, в таком случае принимается решение
об отдельных столбцах, в какой из разделов поместить тот или иной столбец. Такое
разделение осуществляется вручную, как правило.

#### Секционирование индекса

При проведении разделения существует возможность выбора: сделать индекс таблицы
глобальным или локальным. Глобальный индекс работает с целой таблицей, локальный
строится для каждого раздела.

Глабальные индексы полезны в том случае, когда запрос осуществляющихся без
указания ключа секционирования.

#### Методы секционирования

##### Секционирование по диапазону

```
partition by range
```

Наиболее распространен данный случай секционирования в отношении дат.

```
mysql> create table sales (sale_id int not null, sale_date date not null) partition by range (yearweek(sale_date)) (partition s1 values less than (202002), partition s2 values less than (202006), partition s999 values less than (maxvalue));
Query OK, 0 rows affected (0.04 sec)
```

Данный запрос создает таблицу и разбивает её на три партиции: в раздел s1
попадают те строки, для которых значение yearweek(sale_date) меньше 202002-
первая неделя 2020 года. В раздел s2 пападают строки за вторую неделю. В раздел
s999 попадают все остальные строки.

sale_date является ключом секционирования, а yearweek(sale_date) является
функцией секционирования. Узнать информацию о партиционировании можно из таблицы
partitions в information_schema:

```
mysql> select partition_name, partition_method, partition_expression from information_schema.partitions where table_name = 'sales' order by partition_ordinal_position;
+----------------+------------------+-------------------------+
| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION    |
+----------------+------------------+-------------------------+
| s1             | RANGE            | yearweek(`sale_date`,0) |
| s2             | RANGE            | yearweek(`sale_date`,0) |
| s999           | RANGE            | yearweek(`sale_date`,0) |
+----------------+------------------+-------------------------+
```

Придумали себе задачку: разбить раздел s999 на большее число разделов. От СУБД к
СУБД манера выполнения этой задачки меняется, но в MySQL предлагается провернуть
такой трюк через alter table reorganize partition:

```
mysql> alter table sales reorganize partition s999 into (partition s6 values less than (202007), partition s7 values less than (2020008), partition s999 values less than (maxvalue));
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

Внесенные изменения можно проверить:

```
mysql> select partition_name, partition_method, partition_expression from information_schema.partitions where table_name = 'sales' order by partition_ordinal_position;
+----------------+------------------+-------------------------+
| PARTITION_NAME | PARTITION_METHOD | PARTITION_EXPRESSION    |
+----------------+------------------+-------------------------+
| s1             | RANGE            | yearweek(`sale_date`,0) |
| s2             | RANGE            | yearweek(`sale_date`,0) |
| s6             | RANGE            | yearweek(`sale_date`,0) |
| s7             | RANGE            | yearweek(`sale_date`,0) |
| s999           | RANGE            | yearweek(`sale_date`,0) |
+----------------+------------------+-------------------------+
```

Добавим пару строк в таблицу:

```
mysql> insert sales values (1, '2020-01-18'), (2, '2020-02-07');
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

Чтобы узнать о том, в какие разделы попали эти записи, следует выполнить
дурацкий запрос:

```
mysql> select count(*) from sales partition (s1) union all select count(*) from sales partition (s2) union all select count(*) from sales partition (s6) union all select count(*) from sales partition (s7) union all select count(*) from sales partition (s999);
+----------+
| count(*) |
+----------+
|        0 |
|        2 |
|        0 |
|        0 |
|        0 |
+----------+
5 rows in set (0.01 sec)
```

Все так, как и следовало ожидать.

##### Секционирование по списку

Подобрав ключ партицирования возможно указать несколько списоков, на основании
принадлежности к которым и будет определяться то, в какой раздел будет присунута
строка.

```
partition by list columns ('название_колонки') (partition part1 values in ('v1', 'v2', partition part 2 values in ('v3, 'v4'))
```

Стоит отметить, что MySQL будет ругаться и отвергать такие значения, которые не
могут быть определены ни к одной из секций.

##### Секционирование по хэшу

При секционированию по хэшу СУБД применяет функцию вычисления хэша к ключу
партицирования и на основании полученного значения определяет строку в тот или
иной раздел.

Данный способ партицирования удобен, когда множество возможных значений для
ключа секционирования велико, ведь в таком случае MySQL не станет ругаться при
попытке добавить элемент в таблицу, который ей не понятно, куда пихать.

```
partition by hash ('столбец') partitions 4 (partition h1, partition h2, partition h3, partition h4)
```

##### Композитное секционирование

Композитное секционирование позволяет определять два типа секционирования,
основной и тот, по которому будет происходить разделение в группах.

```
partition by range (date(sale_date)) subpartition by hash (id) (partition s1 values less then (2000) (subpartition s1_h1, subpartition s2_h2), (partition s2 values less then (2005)(subpartition s2_h1, subpartition s2_h2)))
```

#### Преимущества секционирования

Главное преимущество секционирования заключается в возможности работы с таблицей
не целиком. Возможно использовать секции в пользовательских запросах, экономящих
время на их обработку, а с точки зрения администратора, секционирование
позволяет творить вообще невероятные вещи.

### Кластеризация

Кластеризация призвана увеличить скорость работы с данными при помощи разделения
нагрузки на несколько серверов.

#### Шардинг

Шардинг позволяет разнести одну базу данных на несколько серверов. Данные
разделяются и хранятся отдельно, в следствие этого нагрузка на каждый из
серверов уменьшается.

Для шардирования требуется ключ шардинга- он определяет то, к какой БД
необходимо выполнить подключение.

Автор в итоге говорит, что тема шардинга очень сложна. Не могу не согласиться

### Большие данные

3V или Volume, Velocity и Variety - три показателя больших данных

Volume или объем - миллиарды или триллионы точек данных, Velocity - скорость, с
которой поступают новые данные, Variety - разнообразие, означает, что данные не
всегда структурированы, а могут быть и вовсе не стрктурированы.

Таким образом, больше данные - любая система, предназначенная для обработки
огромного количества информации

### Hadoop

Hadoop - набор технологий и инструментов, работающих совместно для
функционирования системы с большими данными.

Hadoop включает в себя HDFS - распределенную файловую систему, MapReduce -
технология разбивки задачи на подзадачи с возможностью выполнения её паралельно
на нескольких серверах, YARN - диспетчер ресурсов и планировщки заданий для
HDFS.